--> 39.0
-- extensibility
-- features: embedding typed language
-- operations: eval, pp
-- different evaluation order
--
-- Issue: encode higher kinded polymorphism
-- Use object algebra


type ExpAlg[Repr[_]] = {
  lit : Double -> Repr[Double],
  add : Repr[Double] -> Repr[Double] -> Repr[Double],
  lam : forall A B. (Repr[A] -> Repr[B]) -> Repr[A -> B],
  app : forall A B. Repr[A -> B] -> Repr[A] -> Repr[B]
}


type IEval[E] = { eval : E }

trait evalAlg : ExpAlg[IEval] { self =>
  def lit x  = { eval = x }
  def add x y = { eval = x.eval + y.eval }
  def lam A B f = { eval = \x -> (f {eval = x}).eval }
  def app A B e1 e2 = { eval = e1.eval e2.eval }
}


type IPrint[E] = { print : Double -> String }

trait printAlg : ExpAlg[IPrint] { self =>
  def lit x = { print = \_ -> x.toString }
  def add e1 e2 = { print = \h -> "(" ++ e1.print h ++ " + " ++ e2.print h ++ ")" }
  def lam A B e =
    { print = \h -> let x : String = "x" ++ h.toString
                    in "(\\" ++ x ++ " -> " ++
                       (e {print = \_ -> x}).print (h + 1) ++ ")"
    }
  def app A B e1 e2 = { print = \h -> "(" ++ e1.print h ++ " " ++ e2.print h ++ ")" }
}


type MulExpAlg[Repr[_]] = ExpAlg[Repr] & {
  mul : Repr[Double] -> Repr[Double] -> Repr[Double]
}

trait mulEvalAlg inherits evalAlg : MulExpAlg[IEval] { self =>
  def mul x y = { eval = x.eval * y.eval }
}

trait mulPrintAlg inherits printAlg : MulExpAlg[IPrint] { self =>
  def mul e1 e2 = { print = \h -> "(" ++ e1.print h ++ " * " ++ e2.print h ++ ")" }
}


def e1 (f : MulExpAlg[IEval]) = f.mul (f.add (f.lit 7) (f.lit 2)) (f.lit 4)

def e2 (f : MulExpAlg[IEval]) = f.lam Double Double (\x -> f.add x (e1 f))

def e3 (f : MulExpAlg[IEval]) =  f.add (f.app Double Double (e2 f) (f.lit 1)) (f.lit 2)


-- type IEvalAndPrint[A] = IEval[A] & IPrint[A]

-- trait newAlg(f : Trait[ExpAlg[IEval]], g : Trait[ExpAlg[IPrint]]) : ExpAlg[IEvalAndPrint] { self =>
--   def lit x = (new[ExpAlg[IEval]] f).lit x ,, (new[ExpAlg[IPrint]] g).lit x

--   def lam A B e = (new[ExpAlg[IEval]] f).lam A B (\x -> e (x ,, {print = \_ -> "ss"})) ,, (new[ExpAlg[IPrint]] g).lam A B (\x -> e ({eval = 0} ,, x))

-- }

-- trait newAlg inherits evalAlg & printAlg

-- def e11 (f : ExpAlg[IEvalAndPrint]) = f.lit 7

main = e3 (new[MulExpAlg[IEval]] mulEvalAlg)
