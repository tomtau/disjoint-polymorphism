--> 4.0

{-

Embedding a higher-order domain-specific language (simply-typed lambda-calculus
with conditionals and constants) with a selectable evaluation order: Call-by-value, call-by-name.

-}


type Arr[Expr[_], A, B] = Expr[A] -> Expr[B]

type BindAlg[Expr[_]] = {
  lam : forall A B. (Expr[A] -> Expr[B]) -> Expr[Arr[Expr,A,B]]
}

type IEval[E] = T -> E

type ExprAlg[Expr[_]] = {
  lit : Double -> Expr[Double],
  add : Expr[Double] -> Expr[Double] -> Expr[Double],
  app : forall A B. Expr[Arr[Expr,A,B]] -> Expr[A] -> Expr[B],
  bot : forall A. Expr[A]
}

trait evalAlg : ExprAlg[IEval] { self =>
  def lit n = \_ -> n
  def add e1 e2 = \_ -> e1() + e2()
  def app A B e1 e2 = \_ -> e1() e2()
  def bot A = \_ -> let x : A = x in x
}

type MulAlg[Expr[_]] = ExprAlg[Expr] & {
  mul : Expr[Double] -> Expr[Double] -> Expr[Double]
}


trait evalMul inherits evalAlg : MulAlg[IEval] { self =>
  def mul e1 e2 = \_ -> e1() * e2()
}


type BoolAlg[Expr[_]] = MulAlg[Expr] & {
  bool : Bool -> Expr[Bool],
  le : Expr[Double] -> Expr[Double] -> Expr[Bool],
  iff : forall A. Expr[Bool] -> Expr[A] -> Expr[A] -> Expr[A]

}

trait evalBool inherits evalMul : BoolAlg[IEval] { self =>
  def bool b = \_ -> b
  def le e2 e3 = \_ -> e2() < e3()
  def iff A be et ee = \_ -> if be() then et() else ee()
}


type TermAlg[Expr[_]] = BoolAlg[Expr] & BindAlg[Expr]

trait evalBindCBV  : BindAlg[IEval] { self =>
  def lam A B f = \_ -> \y -> let yv : A = y() in f (\_ -> yv)
}

trait evalBindCBN : BindAlg[IEval] { self =>
  def lam A B f = \_ -> f
}

def makeEvaluator (o : Trait[BindAlg[IEval]]) = new[TermAlg[IEval]] evalBool & o

def ex1 (f : TermAlg[IEval]) = f.app Double Double (f.lam Double Double (\x -> f.lit 4)) (f.bot Double)


{-
-- Infinite loop
main = (ex1 (makeEvaluator evalBindCBV))()
-}

main = (ex1 (makeEvaluator evalBindCBN))()
