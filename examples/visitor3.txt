--> "(5 - (3 + 2)) = 0"

type ExpAlg[E] = {
  lit : Int -> E,
  add : E -> E -> E
}

type Exp = { accept : forall E . ExpAlg[E] -> E }

type IEval = { eval : Int }

trait evalAlg : ExpAlg[IEval] { self =>
  def lit x   = { eval = x }
  def add x y = { eval = x.eval + y.eval }
}


type SubExpAlg[E] = ExpAlg[E] & { sub : E -> E -> E }
trait subEvalAlg inherits evalAlg : SubExpAlg[IEval]  { self =>
  def sub x y = { eval = x.eval - y.eval }
}
type ExtExp = { accept: forall E. SubExpAlg[E] -> E }



type IPrint = { print : String }


trait printAlg : SubExpAlg[IPrint] { self =>
  def lit x   = { print = x.toString }
  def add x y = { print = "(" ++ x.print ++ " + " ++ y.print ++ ")" }
  def sub x y = { print = "(" ++ x.print ++ " - " ++ y.print ++ ")" }
}



def lit (n : Int) : Exp = {
  accept = /\E . \f -> f.lit n
}
def add (e1 : Exp) (e2 : Exp) : Exp = {
  accept = /\E . \f -> f.add (e1.accept E f) (e2.accept E f)
}
def sub (e1 : ExtExp) (e2 : ExtExp) : ExtExp = {
  accept = /\E . \f -> f.sub (e1.accept E f) (e2.accept E f)
}


-- BEGIN_COMBINE1_DEF
trait combine A [B * A] (f : Trait[SubExpAlg[A]] , g : Trait[SubExpAlg[B]])
  : SubExpAlg[A & B] { self =>
  def lit x   = (new[SubExpAlg[A]] f).lit x   ,, (new[SubExpAlg[B]] g).lit x
  def add x y = (new[SubExpAlg[A]] f).add x y ,, (new[SubExpAlg[B]] g).add x y
  def sub x y = (new[SubExpAlg[A]] f).sub x y ,, (new[SubExpAlg[B]] g).sub x y
}
-- END_COMBINE1_DEF



-- BEGIN_COMBINE_DEF
trait combine1 A [B * A] (f : Trait[SubExpAlg[A]], g : Trait[SubExpAlg[B]]) inherits f & g { }
-- END_COMBINE_DEF



def e = sub (lit 5) (add (lit 3) (lit 2))

def newAlg1 = combine1 IEval IPrint subEvalAlg printAlg
def oo = e.accept (IEval & IPrint) (new[SubExpAlg[IEval & IPrint]] newAlg1)


-- BEGIN_COMBINE1_TEST
def newAlg = combine IEval IPrint subEvalAlg printAlg
def o = e.accept (IEval & IPrint) (new[SubExpAlg[IEval & IPrint]] newAlg)
main = o.print ++ " = " ++ o.eval.toString
-- Output: "(5 - (3 + 2)) = 0"
-- END_COMBINE1_TEST
