--> "add1(var x = 3.0; var y = 4.0; (if (x < y) then (x + 2.0) else (y + 3.0))) = 6.0"


-----------------------------
-- Infrastructure
-----------------------------

type MaybeAlg[B, A] = {
  nothing : T -> B,
  just : A -> B
}

type Maybe[A] = {
   match : forall C. MaybeAlg[C,A] -> C
}

def nothing A : Maybe[A] = { match = /\C. \f -> f.nothing() }

def just A (x : A) : Maybe[A] = { match = /\C. \f -> f.just x }

def bind A B (x : Maybe[A]) (f : A -> Maybe[B]) : Maybe[B] =
  x.match Maybe[B] { nothing = \_ -> nothing B, just = \a -> f a }

def fromJust A (x : Maybe[A]) : A =
  x.match A { nothing = \_ -> undefined, just = \b -> b }

def isJust A (x : Maybe[A]) : Bool =
  x.match Bool { nothing = \_ -> false, just = \_ -> true }

type EnvF[E] = String -> Maybe[E]

def empty A : EnvF[A] = \_ -> {match = /\C. \f -> f.nothing()}

def lookup A (s : String) (env : EnvF[A]) = env s

def insert A (s1 : String) (v1 : A) (f : EnvF[A]) : EnvF[A] =
  \s2 -> if s1 == s2 then just A v1 else f s2


type PairAlg[A,B,C] = {
  pairAlg : A -> B -> C
}

type Pair[A,B] = {
  match : forall C. PairAlg[A,B,C] -> C
}


def mkPair A B (x : A) (y : B) : Pair[A,B] = {
  match = /\C. \f -> f.pairAlg x y
}

def fst A B (p : Pair[A,B]) : A = p.match A { pairAlg = \x _ -> x }

def snd A B (p : Pair[A,B]) : B = p.match B { pairAlg = \_ x -> x }

def casePair A B C (p : Pair[A,B]) (f: A -> B -> C) : C =
  p.match C { pairAlg = \a b -> f a b }



-----------------------------
-- Evaluation
-----------------------------

type ValAlg[E] = {
  numV : Double -> E,
  boolV : Bool -> E
}
type Value = {
  match : forall C. ValAlg[C] -> C
}

def numV (n : Double) : Value = { match = /\C. \f -> f.numV n }

def boolV (b : Bool) : Value = { match = /\C. \f -> f.boolV b }

def fromNum (v : Value) : Double =
  v.match Double { numV = \n -> n, boolV = \_ -> undefined}

def fromBool (v : Value) : Bool =
  v.match Bool { numV = \_ -> undefined, boolV = \b -> b }




-----------------------------
-- Type checker
-----------------------------

type TypeAlg[E] = {
  tnum : E,
  tbool : E
}
type Type = {
  match : forall E. TypeAlg[E] -> E
}

def tnum : Type = { match = /\E. \f -> f.tnum }

def tbool : Type = { match = /\E. \f -> f.tbool }

def caseType A (t : Type) (x : A) (y : A) : A =
  t.match A {tnum = x, tbool = y}

def eqTypes (a : Type) (b : Type) : Bool =
  caseType Bool a (caseType Bool b true false) (caseType Bool b false true)



----------------
-- Interfaces
----------------

-- BEGIN_INTERFACE
-- Evaluator
type Env = EnvF[Value]
type IEval = {eval : Env -> Maybe[Value]}

-- Pretty printer
type IPrint = { print : String }

-- Type checker
type TEnv = EnvF[Type]
type ITC = { tcheck : TEnv -> Maybe[Type] }
-- END_INTERFACE



-----------------------------
-- Base arithmetic expression
-----------------------------

-- BEGIN_BASE_DEF
type ArithAlg[E] = {
  num : Double -> E,
  add : E -> E -> E,
  sub : E -> E -> E,
  mul : E -> E -> E,
  div : E -> E -> E
}
type Arith = {
  accept : forall E. ArithAlg[E] -> E
}
-- END_BASE_DEF

def numA (n : Double) : Arith = {
  accept = /\E. \f -> f.num n
}

def addA (e1 : Arith) (e2 : Arith) : Arith = {
  accept = /\E. \f -> f.add (e1.accept E f) (e2.accept E f)
}

def subA (e1 : Arith) (e2 : Arith) : Arith = {
  accept = /\E. \f -> f.sub (e1.accept E f) (e2.accept E f)
}

def mulA (e1 : Arith) (e2 : Arith) : Arith = {
  accept = /\E. \f -> f.mul (e1.accept E f) (e2.accept E f)
}

def divA (e1 : Arith) (e2 : Arith) : Arith = {
  accept = /\E. \f -> f.div (e1.accept E f) (e2.accept E f)
}


-- Evaluator
-- BEGIN_BASE_EVALUATOR
trait evalArithAlg { self =>
  def num (n : Double) : IEval = { eval = \_ -> just Value (numV n) }
  def add (e1 : IEval) (e2 : IEval) : IEval = { eval = \env ->
    bind Value Value (e1.eval env) (\v1 ->
      bind Value Value (e2.eval env) (\v2 ->
        just Value (numV (fromNum v1 + fromNum v2))))
  } -- The rest omitted...
-- END_BASE_EVALUATOR
  def sub (e1 : IEval) (e2 : IEval) : IEval = { eval = \env ->
    bind Value Value (e1.eval env) (\v1 ->
      bind Value Value (e2.eval env) (\v2 ->
        just Value (numV (fromNum v1 - fromNum v2))))
  }
  def mul (e1 : IEval) (e2 : IEval) : IEval = { eval = \env ->
    bind Value Value (e1.eval env) (\v1 ->
      bind Value Value (e2.eval env) (\v2 ->
        just Value (numV (fromNum v1 * fromNum v2))))
  }
  def div (e1 : IEval) (e2 : IEval) : IEval = { eval = \env ->
    bind Value Value (e1.eval env) (\v1 ->
      bind Value Value (e2.eval env) (\v2 ->
        just Value (numV (fromNum v1 / fromNum v2))))
  }
}

-- Pretty pinter
-- BEGIN_PRETTY_BASE
trait ppArithAlg { self =>
  def num (n : Double)                = { print = n.toString }
  def add (e1 : IPrint) (e2 : IPrint) = { print = "(" ++ e1.print ++ " + " ++ e2.print ++ ")"}
  def sub (e1 : IPrint) (e2 : IPrint) = { print = "(" ++ e1.print ++ " - " ++ e2.print ++ ")"}
  def mul (e1 : IPrint) (e2 : IPrint) = { print = "(" ++ e1.print ++ " * " ++ e2.print ++ ")"}
  def div (e1 : IPrint) (e2 : IPrint) = { print = "(" ++ e1.print ++ " / " ++ e2.print ++ ")"}
}
-- END_PRETTY_BASE

-- Type checker
-- BEGIN_TYPECHECKER_BASE
trait tcArithAlg { self =>
  def num (n : Double) : ITC = { tcheck = \_ -> just Type tnum }
  def add (e1 : ITC) (e2 : ITC) : ITC = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (bind Type Type (e2.tcheck env) (\t2 ->
          caseType Maybe[Type] t2
            (just Type tnum)
            (nothing Type)))
        (nothing Type))
  } -- The rest omitted...
-- END_TYPECHECKER_BASE
  def sub (e1 : ITC) (e2 : ITC) : ITC = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (bind Type Type (e2.tcheck env) (\t2 ->
          caseType Maybe[Type] t2
            (just Type tnum)
            (nothing Type)))
        (nothing Type))
  }
  def mul (e1 : ITC) (e2 : ITC) : ITC = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (bind Type Type (e2.tcheck env) (\t2 ->
          caseType Maybe[Type] t2
            (just Type tnum)
            (nothing Type)))
        (nothing Type))
  }
  def div (e1 : ITC) (e2 : ITC) : ITC = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (bind Type Type (e2.tcheck env) (\t2 ->
          caseType Maybe[Type] t2
            (just Type tnum)
            (nothing Type)))
        (nothing Type))
  }
}


def eg1 : Arith = addA (mulA (numA 3) (numA 4)) (numA 5)



-----------------------------------
-- Add Boolean expression variants
-----------------------------------

-- BEGIN_CONDITIONAL
type BoolArithAlg[E] = ArithAlg[E] & {
  bool : Bool -> E,
  eq   : E -> E -> E,
  le   : E -> E -> E,
  iff  : E -> E -> E -> E
}
-- END_CONDITIONAL

type BoolArith = {
  accept : forall E. BoolArithAlg[E] -> E
}

def boolB (b : Bool) : BoolArith = {
  accept = /\E. \f -> f.bool b
}

def eqB (e1 : BoolArith) (e2 : BoolArith) : BoolArith = {
  accept = /\E. \f -> f.eq (e1.accept E f) (e2.accept E f)
}

def leB (e1 : BoolArith) (e2 : BoolArith) : BoolArith = {
  accept = /\E. \f -> f.le (e1.accept E f) (e2.accept E f)
}

def ifB (e1 : BoolArith) (e2 : BoolArith) (e3 : BoolArith) : BoolArith = {
  accept = /\E. \f -> f.iff (e1.accept E f) (e2.accept E f) (e3.accept E f)
}


-- Evaluator
trait evalBoolArithAlg inherits evalArithAlg : BoolArithAlg[IEval] { self =>
  def bool b          = { eval = \_ -> just Value (boolV b) }
  def eq e1 e2        = { eval = \env ->
    bind Value Value (e1.eval env) (\v1 ->
      bind Value Value (e2.eval env) (\v2 ->
        just Value (boolV (fromNum v1 == fromNum v2))))
  }
  def le e1 e2        = { eval = \env ->
    bind Value Value (e1.eval env) (\v1 ->
      bind Value Value (e2.eval env) (\v2 ->
        just Value (boolV (fromNum v1 < fromNum v2))))
  }
  def iff e1 e2 e3 = { eval = \env ->
    bind Value Value (e1.eval env) (\b ->
      if fromBool b
      then e2.eval env
      else e3.eval env)
  }
}

-- Pretty printer
trait ppBoolArithAlg inherits ppArithAlg : BoolArithAlg[IPrint] { self =>
  def bool b          = { print = b.toString }
  def eq e1 e2        = { print = "(" ++ e1.print ++ " == " ++ e2.print ++ ")" }
  def le e1 e2        = { print = "(" ++ e1.print ++ " < " ++ e2.print ++ ")" }
  def iff e1 e2 e3 =
    { print = "(if " ++ e1.print ++ " then " ++ e2.print ++ " else " ++ e3.print ++ ")" }
}


-- Type checker
trait tcBoolArithAlg inherits tcArithAlg : BoolArithAlg[ITC] { self =>
  def bool b   = { tcheck = \_ -> just Type tbool }
  def eq e1 e2 = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (bind Type Type (e2.tcheck env) (\t2 ->
          caseType Maybe[Type] t2
            (just Type tbool)
            (nothing Type)))
        (nothing Type))
  }
  def le e1 e2 = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (bind Type Type (e2.tcheck env) (\t2 ->
          caseType Maybe[Type] t2
            (just Type tbool)
            (nothing Type)))
        (nothing Type))
  }
  def iff e1 e2 e3 = { tcheck = \env ->
    bind Type Type (e1.tcheck env) (\t1 ->
      caseType Maybe[Type] t1
        (nothing Type)
        (bind Type Type (e2.tcheck env) (\t2 ->
          (bind Type Type (e3.tcheck env) (\t3 ->
            caseType Maybe[Type] t2
              (caseType Maybe[Type] t3
                (just Type t2)
                (nothing Type))
              (caseType Maybe[Type] t3
                (nothing Type)
                (just Type t2)))))))
  }
}


def eg2 : BoolArith = ifB (eqB (numA 3) (numA 5)) (numA 12) (addA (numA 12) (numA 22))


-----------------------------
-- Add variable declarations
-----------------------------

-- BEGIN_VARIABLE
type VarArithAlg[E] = BoolArithAlg[E] & {
  var : String -> E,
  decl : String -> E -> E -> E
}
-- END_VARIABLE

type VarArith = {
  accept : forall E. VarArithAlg[E] -> E
}

def varV (n : String) : VarArith = {
  accept = /\E. \f -> f.var n
}

def declV (n : String) (e1 : VarArith) (e2 : VarArith) : VarArith = {
  accept = /\E. \f -> f.decl n (e1.accept E f) (e2.accept E f)
}


-- Evaluator
-- BEGIN_EVALUATOR_VARIABLE
trait evalVarArithAlg inherits evalBoolArithAlg { self =>
  def var (n : String) : IEval = { eval = \env -> lookup Value n env }
  def decl (n : String) (e : IEval) (b : IEval) : IEval = { eval = \env ->
    bind Value Value (e.eval env) (\v ->
      b.eval (insert Value n v env))
  }
}
-- END_EVALUATOR_VARIABLE

-- Pretty printer
-- BEGIN_PRETTY_VARIABLE
trait ppVarArithAlg inherits ppBoolArithAlg : VarArithAlg[IPrint] { self =>
  def var n      = { print = n }
  def decl n e b = { print = "var " ++ n ++ " = " ++ e.print ++ "; " ++ b.print }
}
-- END_PRETTY_VARIABLE

-- Type checker
-- BEGIN_TYPECHECKER_VARIABLE
trait tcVarArithAlg inherits tcBoolArithAlg : VarArithAlg[ITC] { self =>
  def var n      = { tcheck = \env -> lookup Type n env }
  def decl n e b = { tcheck = \env ->
    bind Type Type (e.tcheck env) (\t ->
      b.tcheck (insert Type n t env))
  }
}
-- END_TYPECHECKER_VARIABLE


-----------------------------
-- Add top-level functions
-----------------------------

-- BEGIN_TOP_LEVEL
type ExpAlg[E] = VarArithAlg[E] & {
  call : String -> E -> E
}
type Exp = {
  accept : forall E. ExpAlg[E] -> E
}
-- END_TOP_LEVEL

def callF (n : String) (e : Exp) : Exp = {
  accept = /\E. \f -> f.call n (e.accept E f)
}


type FnAlg[E] = {
  fnAlg : String -> Type -> Type -> Exp -> E
}

type Function = {
  accept : forall E. FnAlg[E] -> E
}

def caseFn E (x : Function) (f : String -> Type -> Type -> Exp -> E) : E =
  x.accept E { fnAlg = f }

type FEnv = EnvF[Function]

type PgmAlg[E] = {
  pgmAlg : FEnv -> Exp -> E
}

type Program = {
  accept : forall E. PgmAlg[E] -> E
}

def casePgm E (p : Program) (f: FEnv -> Exp -> E) : E =
  p.accept E { pgmAlg = f }


-- Evaluator
trait evalExpAlg(fenv : FEnv) inherits evalVarArithAlg : ExpAlg[IEval] { self : ExpAlg[IEval] =>
  def call f arg = { eval = \env ->
    bind Function Value (lookup Function f fenv) (\fn ->
      caseFn Maybe[Value] fn
        (\param _ _ body ->
          bind Value Value (arg.eval env)
            (\v -> (body.accept IEval self).eval (insert Value param v env))))
  }
}

-- Pretty printer
trait ppExpAlg inherits ppVarArithAlg : ExpAlg[IPrint] { self =>
  def call f arg = { print = f ++ "(" ++ arg.print ++ ")" }
}

-- Type checker

type FTEnv = EnvF[Pair[Type, Type]]

trait tcExpAlg(ftenv : FTEnv) inherits tcVarArithAlg : ExpAlg[ITC] { self =>
  def call f arg = { tcheck = \env ->
    bind Pair[Type,Type] Type (lookup Pair[Type,Type] f ftenv) (\p ->
      casePair Type Type Maybe[Type] p (\a b ->
        bind Type Type (arg.tcheck env) (\a' ->
          if eqTypes a a' then just Type b else nothing Type)))
  }
}

def checkFEnv (fenv : FEnv) : FTEnv = \n ->
  bind Function Pair[Type, Type] (lookup Function n fenv) (\f ->
    caseFn Maybe[Pair[Type, Type]] f (\arg typ ret body ->
    (just Pair[Type,Type] (mkPair Type Type typ ret))))


-----------------------
-- Put all together
-----------------------

def add1Body : Exp = {
  accept = /\E. \f -> f.add (f.var "x") (f.num 1)
}

def add1 : Function = {
  accept = /\E. \f -> f.fnAlg "x" tnum tnum add1Body
}

def fenv : FEnv = insert Function "add1" add1 (empty Function)

-- BEGIN_FINAL_TEST
-- add1(var x = 3; var y = 4; if x < y then x + 2 else y + 3)
def test : Program = {accept = /\E. \p -> p.pgmAlg fenv { accept = /\F. \f ->
  f.call "add1"
    (f.decl "x" (f.num 3)
      (f.decl "y" (f.num 4)
        (f.iff (f.le (f.var "x") (f.var "y"))
          (f.add (f.var "x") (f.num 2))
          (f.add (f.var "y") (f.num 3)))))}}
-- END_FINAL_TEST

-- BEGIN_SUPER_DEF
type SuperAlg = IEval & IPrint & ITC
def evalPgm (p : Program) : String =
  casePgm String p (\fenv m ->
    let ftenv : FTEnv = checkFEnv fenv in
    let op1 : ExpAlg[IEval]  = new[ExpAlg[IEval]] evalExpAlg(fenv) in
    let op2 : ExpAlg[IPrint] = new[ExpAlg[IPrint]] ppExpAlg in
    let op3 : ExpAlg[ITC]    = new[ExpAlg[ITC]] tcExpAlg(ftenv) in
    let superAlg : ExpAlg[SuperAlg] = op1 ,, op2 ,,  op3 in
    let inst : SuperAlg = m.accept SuperAlg superAlg in
    if isJust Type (inst.tcheck (empty Type))
    then inst.print ++ " = " ++ (fromNum (fromJust Value (inst.eval (empty Value)))).toString
    else "Type error!")
-- END_SUPER_DEF

-- BEGIN_TEST_TEST
main = evalPgm test
-- Output: "add1(var x = 3.0; var y = 4.0; (if (x < y) then (x + 2.0) else (y + 3.0))) = 6.0"
-- END_TEST_TEST
