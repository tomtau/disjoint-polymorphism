\section{Desugaring}
\label{sec:desugar}


The section provides the procedures of desugaring traits to \bname. The idea
behind trait translation is inspired by the functional mixin semantics using
open recursion, which is proposed by~\citet{cook1989denotational} in an untyped
setting. However, our translation is done in the context of a statically-typed
programming language, which is exactly why conflicts can be \textit{statically}
detected in traits.

The syntax of \bname is shown in Figure~\ref{fig:synax-fi}.

\begin{figure}[t]
\centering
% \begin{small}
\begin{tabular}{lrcl}
  Types  & $[[A]], [[B]]$ & ::= & $[[top]] \mid [[Int]] \mid [[Bool]] \mid [[String]] \mid [[A -> B]] \mid [[A & B]] \mid  [[{ l : A }]]  $ \\
         && $\mid$ & $[[a]] \mid [[forall ( a ** A ) . B]] \mid [[ A [ B1 ... Bn ] ]]$ \\
  Expressions & $[[E]]$ & ::= & $[[top]] \mid [[N]] \mid [[S]] \mid [[E1 + E2]] \mid [[E1 - E2]] \mid [[E1 * E2]] \mid [[E1 / E2]] \mid [[E1 ,, E2]] $ \\
         && $\mid$ & $[[BL]] \mid [[E1 == E2]] \mid [[E1 /= E2]] \mid [[E1 < E2]] \mid [[E1 > E2]] \mid [[if E1 then E2 else E3]] $ \\
         && $\mid$ & $[[x]] \mid [[\ x . E]] \mid [[E1 E2]] \mid [[blam ( a ** A ) . E]] \mid [[E A]]$ \\
         && $\mid$ & $[[{ l = E }]] \mid [[E . l]] \mid [[E -- l]] \mid [[let x : A = E1 in E2]]$ \\
  Programs & $[[pgm]]$ & ::= & $[[decl1 .. decln E]]$ \\
  Declarations & $[[decl]]$ & ::= & $[[ def f ( x1 : A1 ) .. ( xm : Am ) : B = E ]] \mid [[ type T a1 .. an = A ]]$
\end{tabular}
% \end{small}
\caption{Syntax of \bname }
\label{fig:synax-fi}
\end{figure}

\subsection{Trait Declarations}

Essentially traits are translated into term declarations, with methods becoming
record fields. The self-reference is adjusted to be the last parameter of the
declaration. For example,
\begin{lstlisting}
  trait point(x : Int, y: Int) { self : Point =>
    def x() = x
    def y() = self.x()
  }
\end{lstlisting}
becomes
\begin{lstlisting}
  def point (x : Int) (y : Int) (self : Point) =
  { x = \_ -> x
  , y = \_ -> self.x()
  }
\end{lstlisting}

Now it is clear that \lstinline{self} is not a special keyword: it can
have any name.

More formally, a trait of the form
\begin{lstlisting}[mathescape=true]
  trait m [$A_1$, ..., $A_n$] ($x_1 : A_1$, ..., $x_n : A_n$) inherits $a_1$ & ... & $a_n$ { s : $A_0$ =>
    def $m_1$(...) = $e_1$
    ...
    def $m_n$(...) = $e_n$
  }
\end{lstlisting}
is translated into a term declaration of the form
\begin{lstlisting}[mathescape=true]
  def m $A_1$ ... $A_n$ $(x_1 : A_1)$ ... $(x_n : A_n)$ $(s : A_0)$ = $a_1$(s) ,, ... ,, $a_n$(s) ,,
  {
    $m_1$ = \(...) -> $e_1$
  , ...
  , $m_n$ = \(...) -> $e_n$
  }
\end{lstlisting}


\subsection{Instantiations of Traits}

\name allows creating a single object from one or more traits. Specifically,
\lstinline{new} instantiates a trait by taking the fixpoint of its
corresponding open term. In fact, \lstinline{new} is translated as an inlined
fixpoint. For example,
\begin{lstlisting}
  new[Point] point(3,4)
\end{lstlisting}
becomes
\begin{lstlisting}
  let self : Point = point 3 4 self in self
\end{lstlisting}
Essentially the open term is closed using \textit{lazy fixpoints}. Lazy
fixpoints are a standard way to encode dynamic mixin inheritance and bind
self-reference in denotational semantics~\cite{cook1989denotational}.

Lazy fixpoints are implemented in \name using the built-in \lstinline{let}
construct (possibly recursive), which employs call-by-name semantics. It is
possible to choose call-by-value, then the type of the self-reference would
becomes a thunk, that is, \lstinline$T -> Point$.

The composition of traits in the \lstinline{new} expression is desugared using
the merge operator. Now it is clear that the reason traits have conflict
detection for free is that the merge operator is enforcing two terms being
merged are disjoint. For example,
\begin{lstlisting}
  new[Point & Norm] point(3,4) & euclideanNorm()
\end{lstlisting}
is turned into
\begin{lstlisting}
  let self : Point & Norm = (point 3 4 self) ,, (euclideanNorm () self) in self
\end{lstlisting}

Formally, a \lstinline{new} expression of the form
\begin{lstlisting}[mathescape=true]
  new[$A_1$ & ... & $A_n$] $a_1$ & ... & $a_n$
\end{lstlisting}
is translated into a let expression of the form
\begin{lstlisting}[mathescape=true]
  let self : $A_1$ & ... & $A_n$ = $a_1$(self) ,, ... ,, $a_n$(self) in self
\end{lstlisting}

\subsection{The Type for Traits}

\lstinline[mathescape=true]{Trait[$T_1, T_2$]} denotes the type of those traits
which provide an interface described by the type $T_2$ with dependency on $T_1$.
In fact, it is just like a type constructor except for the fact that it is
built-in in the language, and that the encoding is not exposed to the
programmers.

Formally, a trait type of the form \lstinline[mathescape=true]{Trait[$T_1, T_2$]} becomes \lstinline[mathescape=true]{$T_1$ -> $T_2$}.

\subsection{Record System}

Following~\citet{reynolds1997design} and~\citet{castagna1995calculus}, \name
leverages intersection types to type extensible records. The idea is that a
multi-field record can be encoded as merges of single-field records, and
multi-record types as intersections. Therefore in \name, there are only
single-field record constructs. As such, record operations in \name can occur on
\textit{any} type.

\subsubsection{Record Operations}

To illustrate the various operations on records, we consider a record with three
fields:
\begin{lstlisting}
  {open : Int, high : Int, low : Int}
\end{lstlisting}
Note that this type is just syntactic sugar for:
\begin{lstlisting}
  {open : Int} & {high : Int} & {low : Int}
\end{lstlisting}
That is, a multi-field record type is desugared as intersections of single-field
record types.

\name supports three primitive operations related to records:
\textit{construction} \textit{selection} and \textit{restriction}.
\textit{Extension}, described in many other record systems, is delegated to the
merge operator. Working with records is type-safe: the type system prevents
accessing a field that does not exist.

\paragraph{Record construction.} The usual notation for constructing records
\begin{lstlisting}
  {open = 192, high = 195, low = 189}
\end{lstlisting}
is a shorthand for merges of single-field records
\begin{lstlisting}
  {open = 192} ,, {high = 195} ,, {low = 189}
\end{lstlisting}

\paragraph{Record selection.} Fields are extracted using the dot notation. For
example,
\begin{lstlisting}
  {open = 192, high=195, low= 189}.open
\end{lstlisting}
selects the value of the field labelled \lstinline{open} from the record. Since
records are just merges of terms, we can even select a field that is buried deep
inside a merge, so long as it is present.
\begin{lstlisting}
  ({open = 192} ,, 3 ,, {low = 189}).open
\end{lstlisting}

\jeremy{say something about record restriction}

\paragraph{Record extension} Extension, just like construction, is implemented
with the merge operator. The following example adds a \lstinline{close} field to
the record:
\begin{lstlisting}
  {open = 192, high=195, low=189} ,, {close = 195}
\end{lstlisting}


\begin{comment}
\subsubsection{Restriction via Subtyping}

Unlike most record systems, restriction is not a primitive operation in \name.
Instead, \name uses subtyping for restriction. Combined with disjoint
quantification, we can encode a \lstinline{remove} function that removes a given
field from a record:
\lstinputlisting[linerange=5-5]{../examples/record.txt}% APPLY:linerange=RCD_DEF
\lstinline{remove} takes a value x which contains a record of type
\lstinline${low : Int}$ as well as some extra information of type \lstinline{B}.
The disjointness constraint ensures that the value of type \lstinline{B} does
not contain a record with type \lstinline${low : Int}$. The following examples
shows removing the \lstinline{low} field:
\lstinputlisting[linerange=10-11]{../examples/record.txt}% APPLY:linerange=RCD_EG
\end{comment}


\subsubsection{Disjointness of Records}

Most record calculi forbid duplicate labels in the declarations of record types.
Some allow labels coincide but the last field overrides the previous ones.
Records in \name allow duplicate labels. This is because we adopt a lenient
approach to record disjointness~\cite{alpuimdisjoint}. Of course records with
distinct fields are disjoint naturally. \name accepts duplicate labels as long
as the types of the overlapping fields are disjoint. For example,
\begin{lstlisting}
  {open = 192, high = 195, open = true}
\end{lstlisting}
is allowed in \name. An interesting question arises when we try to select a
duplicate label, say \lstinline{open}. What should be the result? Should it be
192 or \lstinline{true}? Neither choice is satisfying, as with the coherence
problem for merges. Instead \name rejects such expression, and asks for more
type information from the context. Thus the following is accepted because there
is only one \lstinline{open} associated with \lstinline{Int}.
\begin{lstlisting}
  {open = 192, high = 195, open = true}.open + 3
\end{lstlisting}

\section{Implementation}

The \name prototype implementation is structured around a typed core language
(\bname with some extensions). The main component of the implementation is an
elaborating type-checker, which takes a \bname expression, checks it, and
produces another expression in the target language. The final expression is then
directly executed by an interpreter. We chose call-by-name untyped lambda
calculus as the target language. Since we focus on the implementation, and types
are irrelevant after type checking, untyped lambda calculus is a suitable choice
with minimal syntax. With some simple optimization, the interpreter delivers
reasonably good execution efficiency.

The overall implementation is unremarkable, as it closely follows the semantics
that was presented by~\citet{alpuimdisjoint}. The whole pipeline is shown in
Figure~\ref{fig:pipeline}. The desugaring phase (cf. Section~\ref{sec:desugar})
takes a simple abstract syntax tree (AST) generated by the parser, and returns a
\bname expression. Trait-related constructs disappear after this phase. The
type checking phase then takes a \bname expression from the previous phase, it
infers and checks its type, and in the meantime, produces an expression in the
target language. The type checker is the most involved component in the
pipeline. It contains a (coercive) subtyping procedure and a disjointness
checker, both of which are the most essential parts for \name to work as we
wanted it. The target expression (pure untyped lambda calculus) then enters the
final phase, and is executed by a simple interpreter.

The prototype implementation is written in just 1400 lines of Haskell code.

\begin{figure}
  \centering
  \includegraphics[scale=0.9]{pipeline.eps}
  \caption{The pipeline of \name}
  \label{fig:pipeline}
\end{figure}