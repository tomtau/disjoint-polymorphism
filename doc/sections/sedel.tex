\section{Object Algebras and Extensible Visitors in \name}

This section shows that \name features are enough for encoding extensible designs that
been presented in mainstream languages. Moreover \name addresses
limitations of those languages, making those designs
significantly simpler. There are two main advantages of \name
over existing languages:
\begin{enumerate}
\item \name supports dynamic inheritance.
\item \name does not couple type inheritance and subtyping. Moreover
\name supports contravariant parameter types in the subtyping
relation.
\end{enumerate}

These two features avoid the use of low-level programming
techniques, and make the designs less reliant on advanced
features of generics.

\subsection{First-Class Object Algebras Values: A Case for Inheritance
is not Subtyping}
\label{sec:objectalgebra}

Oliveira and Cook~\cite{} proposed a design pattern that can
solve the Expression Problem in languages like Java. An
advantage of the pattern over previous solutions is that it is
relatively lightweight in terms of type system features. However, 
a problem with Object Algebras is that it is hard to pass 
values built with Object Algebras around, since there are 
no concrete expressions/AST types. This problem happens, not 
because this is a fundamental limitation of Object Algebras, but 
because the type systems of OO languages like Java or Scala 
is too restricted to express the types of first-class Object Algebra
values directly. Fortunally \name has no such restriction as
illustrated next. 

\begin{comment}
In a
latter paper, Oliveira et al.~\cite{} noted some limitations of the
original design pattern and proposed some new techniques
that generalized the original pattern, allowing it to express
programs in a Feature-Oriented Programming~\cite{} style. Key
to these techniques was the ability to dynamically compose
object algebras.

Unfortunatelly, dynamic composition of object algebras
is non-trivial. At the type-level it is possible to express the
resulting type of the composition using intersection types.
Thus, it is still possible to solve that part problem nicely in a
language like Scala (which has basic support for intersection
types). However, the dynamic composition itself cannot be
easily encoded in Scala. The fundamental issue is that Scala
lacks a merge operator (see the discussion in Section~\ref{}).
Although both Oliveira et al.~\cite{} and Rendell et al.~\cite{}
have shown that such a merge operator can be encoded in
Scala, the encoding fundamentally relies in low-level programming
techniques such as dynamic proxies, reflection or
meta-programming.

Because \name supports a merge operator natively, dynamic
object algebra composition becomes easy to encode. The
remainder of this section shows how object algebras and
object algebra composition can be encoded in \name. We will
illustrate this point step-by-step by solving the Expression
Problem~\cite{}.

\name provides two main advantages:

\begin{itemize}

\item {\bf First-class object algebra values:} Due to the separation
  of inheritance and subtyping, \name can express first-class Object
  Algebra values. The key aspect is that AST extensions become
  supertypes of the original ASTs. This is unexpressible in many
  languages, but expressible in \name.

\item {\bf Built-in composition for object algebras:} The inheritance
  mechanisms of \name can express Object Algebra delegation-based composition operators~\cite{}
  directly. This is in contrast to previous work, where such operators
  have to be encoded, with significant amounts of boilerplate, with
  either pairs or intersection types. Moreover, the built-in support
  for composition operators \emph{guarantees} safe and unambigous
  composition, which is not guaranteed in previous work. 

\end{itemize}

Various solutions to the Expression Problem~\cite{wadler1998expression} in the
literature~\cite{finally-tagless,oliveira09modular,DelawareOS13,oliveira2012extensibility,
  swierstra:la-carte} are closely related to type-theoretic encodings of
datatypes. Indeed, variants of the same idea keep appearing in different
programming languages, because the encoding of the idea needs to exploit the
particular features of the programming language (or theorem prover).
Unfortunately language-specific constructs obscure the key ideas behind those
solutions. In this section we presents \name's solution to the Expression
Problem that intends to capture the key ideas of various solutions in the
literature.

\subsection{Extensibility and Subtyping}
\label{sec:extensibility}
\end{comment}

\paragraph{Simple expressions}
To start, we begin with a very simple system modeling arithmetic expressions and
evaluation. The initial system constitutes expressions with two variants
(literals and addition), as depicted below:
\lstinputlisting[linerange=4-7]{../examples/visitor.txt}% APPLY:linerange=ALGEBRA_DEF

The first part, captured by the type \lstinline{ExpAlg[E]}, constitutes the
so-called object algebra interface. The first component abstracts over the type
of literal expressions (\lstinline{Int -> E}). The second component abstracts
over the type of addition expression (\lstinline{E -> E -> E}).

\paragraph{An AST for expressions}
The second part, which is the actual type of the arithmetic expression, is:
\lstinputlisting[linerange=11-11]{../examples/visitor.txt}% APPLY:linerange=CHURCH_DEF
An attentive reader may immediately recognize this is a variant of the VISITOR
pattern. Indeed, as already noted by Oliveira and Cook~\cite{}, Object
Algebras are closely related internal visitors~\cite{}. Object
Algebras in languages like Java or Scala do not define the type
\lstinline{Exp} because this would preclude extensibility in those
languages. However in \name it is still possible to define
\lstinline{Exp} and retain extensibility, as illustrated next.

\paragraph{Data constructors.} Using \lstinline{Exp} the two data constrcutors
are defined as follows:
\lstinputlisting[linerange=15-20]{../examples/visitor.txt}% APPLY:linerange=DC_DEF
% Note that the notation \lstinline{/\E} is type abstraction: it introduces a type
% variable in the environment.

\paragraph{Operations.} Defining operations over expressions requires
implementing \lstinline{ExpAlg[E]}. An interesting operation over expressions is
evaluation. The first step is to choose a suitable concrete type for
instantiating the type parameter \lstinline{E}. One such suitable type is:
\lstinputlisting[linerange=25-25]{../examples/visitor.txt}% APPLY:linerange=EVAL_DEF
Using \lstinline{IEval}, we can define a trait that implements the evaluation
rule for each variant:
\lstinputlisting[linerange=29-32]{../examples/visitor.txt}% APPLY:linerange=EVAL_IMPL


\paragraph{Add a subtraction variant.} Interesting things happen when a new
variant, such as subtraction is added. To do so, we need to extend both
\lstinline{ExpAlg[E]} and \lstinline{evalAlg}:
\lstinputlisting[linerange=37-41]{../examples/visitor.txt}% APPLY:linerange=SUB_DEF
Firstly, \lstinline{SubExpAlg[E]} defines an extended algebra that contains the
variants of the original plus the new subtraction variant. Intersection types
are used to model \textit{type inheritance}. Secondly, a new type of expressions
(\lstinline{ExtExp}) with subtraction is needed. It is important to note that
the \lstinline{accept} method now takes the new algebra \lstinline{SubExpAlg[E]}
as argument.

\paragraph{Inheritance is not subtyping.} In the presence of subtyping, there
are interesting subtyping relations between datatypes and their
extensions~\cite{oliveira09modular}. An interesting aspect about subtyping in
the new system is that subtyping follows the opposite direction of the
extension. In other words, subtyping is contravariant with respect to the
extension. First note that \lstinline{SubExpAlg[E]} appears in parameter
position of \lstinline{accept} and function parameters are naturally
contravariant: \lstinline{ExtExp} should be a \textit{supertype} of
\lstinline{Exp}. By contrast, in common OO languages, type inheritance and
subtyping always go along together. For example, Scala forbids any kind of
type-refinement on method parameter types. The consequence of this is that in
those languages, it is impossible to express that \lstinline{ExtExp} is both an
extension and a supertype of \lstinline{Exp}. Such kind of phenomena is an
example where ``inheritance is not
subtyping''~\cite{cook1989inheritance}. In \name, however,
\lstinline{ExtExp} is indeed a supertype of \lstinline{Exp}.

\paragraph{Add a new operation.} The second type of extension is adding a new
operation, such as pretty printing. Similar to evaluation, the interface of the
pretty printing feature is modeled as:
\lstinputlisting[linerange=47-47]{../examples/visitor.txt}% APPLY:linerange=PRINT_DEF
The implementation is spelled out straightforwardly:
\lstinputlisting[linerange=52-56]{../examples/visitor.txt}% APPLY:linerange=PRINT_IMPL

\paragraph{First-class Object Algebra values.} Values of \lstinline{Exp} and
\lstinline{ExtExp} are first-class, meaning they can be passed around or
returned from other functions. We demonstrate that by defining two functions,
one is the \lstinline{sub} constructor, the other is a true evaluator for
\lstinline{ExtExp} (\lstinline{print} for pretty printer can be defined in a
similar way).
\lstinputlisting[linerange=61-64]{../examples/visitor.txt}% APPLY:linerange=EVAL_PRINT
We define two expressions, one of type \lstinline{Exp}, the other
\lstinline{ExtExp}:
\lstinputlisting[linerange=69-70]{../examples/visitor.txt}% APPLY:linerange=EXPRESSION_EG
Notice that we are able to pass \lstinline{e1}, which is of type
\lstinline{Exp}, to \lstinline{sub}, which expects a value of type
\lstinline{ExtExp}. This works precisely because \lstinline{Exp} is a
\textit{subtype} of \lstinline{ExtExp}. An acute reader by now may find an issue
about code reuse, i.e., we cannot reuse constructors! For example, the following
is rejected:
\lstinputlisting[linerange=75-75]{../examples/visitor.txt}% APPLY:linerange=EXPRESSION_WRONG
Instead, \lstinline{e3} should be written as follow:
\lstinputlisting[linerange=80-80]{../examples/visitor.txt}% APPLY:linerange=EXPRESSION_CORRECT
Although, admittedly, creating expressions like this is slightly more
cumbersome. Finally we can test the shiny new system:
\lstinputlisting[linerange=84-87]{../examples/visitor.txt}% APPLY:linerange=VISITOR_EG

\bruno{I though we discussed that data constructors as follows is a bad idea as
they did not provide reuse. Please write code in the style we
discussed previously. Present constructors written in that way for the
basic expressions and present sub only here. Discuss the issue that we
encountered to justify this alternative design!} \jeremy{done}


\subsection{Native Dynamic Object Algebra Composition Support}
\label{sec:dynamic}

The solution to the Expression Problem presented in
Section~\ref{sec:extensibility} has one wrinkle in its usage. To be able to call
different operations from the same expression \lstinline{e}, we need to make two
copies \lstinline{o1} and \lstinline{o2}: one is used for printing, while the
other is used for evaluation. An ideal approach would be allowing a single object
to be created that supports both the printing and evaluation features.
Unfortunately, dynamic composition of algebras is non-trivial.
\citet{oliveira2012extensibility} addressed this problem by proposing
\textit{object algebra combinators} that combine multiple algebras into one.
However, as they noted, such combinators written in Java are difficult to use in
practice. A version of this combinator has been encoded in Scala using
intersection types and an encoding of the merge
operator~\cite{oliveira2013feature, rendel14attributes}. Again, the Scala
encoding of the merge operator is quite complex as it relies on low-level
type-unsafe programming features such as dynamic proxies, reflection or other
meta-programming techniques. In \name there is no need for such complex
encoding, as the merge operator is natively supported.

The combinator is defined by the \lstinline{combine} trait, which takes two
algebras to create a combined algebra. It does so by appropriately delegating
behaviours in each component algebra to the combined algebra.

\lstinputlisting[linerange=49-53]{../examples/visitor3.txt}% APPLY:linerange=COMBINE1_DEF

\bruno{Well, the previous subsection already introduces parametric
  polymorphism, so this discussion comes too late!}
Something new appears the above trait declaration. \name supports parametric
polymorphism. In \name, type variables use uppercase letters. Following the work
of~\citet{alpuimdisjoint}, \name uses an extension to universal quantification
called \textit{disjoint quantification}, where a type variable can be
constrained so that it is disjoint with a given type (\lstinline{B * A} for
example). Parametric polymorphism is need because \lstinline{combine} must
compose algebras with arbitrary type parameters. A disjointness constraint is
needed to ensure that two input algebras build values of disjoint types
(otherwise ambiguity could arise).

With \lstinline{combine} at hand, we can finally have a object \lstinline{o}
print and evaluate at the same time:

\lstinputlisting[linerange=71-74]{../examples/visitor3.txt}% APPLY:linerange=COMBINE1_TEST

An acute reader may have smelled some boilerplate code in the definition of
\lstinline{combine}. After all, \lstinline{combine} just invokes the
corresponding method on the arguments, which is solely driven by the types of
the two input algebras and the resulting algebra. It turns out that the type
system behind \name is powerful enough to derive such definition for us:
\lstinline{combine} is no more than just the merge of two algebras!

\lstinputlisting[linerange=59-59]{../examples/visitor3.txt}% APPLY:linerange=COMBINE_DEF

That's it. No more boilerplate necessary. Two points worth noting: 1) \name
supports \textit{dynamic inheritance}. Notice how we let \lstinline{combine1}
``inherits'' \lstinline{f & g}, for which the implementation is unknown
statically. 2) \name supports multiple inheritance of traits with the same type:
both \lstinline{f} and \lstinline{g} are traits of the subtraction algebra. Type
systems for many OO languages are too inflexible to express this kind of dynamic
inheritance. \name hits a sweet spot in the design space of being how much
dynamic, where we retain much of the flexibility of dynamic languages without
sacrificing the type-safety guarantees.
