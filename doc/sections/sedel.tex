\section{A Tour of \name}

This section showcases the novel features of \name, notably its native support
for dynamically composable traits. We demonstrate by two examples that \name
overcomes all those limitations mentioned in Section~\ref{sec:critique}.

All code snippets in this section are runnable in our prototype
implementation.


\subsection{Dynamically Composable Traits}
\label{sec:traits}

\name natively supports a simple, yet expressive form of dynamically composable
traits~\cite{scharli2003traits}. Traits provide a mechanism of code reuse in
object-oriented programming, that can be used as an alternative to multiple
inheritance. One interesting aspect about traits is the way conflicting features
that are typical arise in multiple inheritance are dealt with. Instead of
automatically resolved by scoping rules, conflicts are detected by the type
system, and require programmers to explicitly resolve them. In what follows, we
demonstrate various trait features in \name. A comparison with the traditional
trait model can be found in Section~\ref{sec:discuss}. The desugaring process
from traits to \bname is discussed in Section~\ref{sec:desugar}.

We describe a representation of graphical objects such as circles, ovals, or
buttons as our first running example. The example is adapted from a blog
post\footnote{\url{https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/}}.
We will use traits to structure the representation and factor out reusable
components. Along the way, we also explain briefly how various features in \name
are encoded behind the scene.


\subsubsection{Specifying Traits}

A Trait is, in essential, a collection of related methods that characterize only
a specific perspective of the features of an object. Therefore, compared with
programs using inheritance, programs using traits usually have a large number of
small traits rather than fewer but larger classes. Code reuse with traits is
easier than with classes, since traits are usually shorter and can be
\textit{composed}. It is the ease of composition that makes traits such a
appealing language feature: two traits can be freely ``added'' together (which
is an symmetric operation); and trait systems provide conflict detection, etc.

Here is a simple trait \lstinline{point} with its two coordinates \lstinline{x}
and \lstinline{y}.
\lstinputlisting[linerange=4-8]{../examples/box.txt}% APPLY:linerange=POINT_DEF
The syntax is very similar to Scala's, with the \lstinline{def} keyword
beginning a term declaration.

At this point the reader may wonder what is the \lstinline{type} declaration
(\lstinline$Point$) for. In mainstream OO languages such as Java, a class
declaration such as \lstinline[language=java]$class C { ... }$ does two things
at the same time:

\begin{itemize}
\item Declaring a \textit{template} for creating object;
\item Declaring a new \textit{type}.
\end{itemize}

In contrast, trait declarations in \name only do the former. The purpose of
declaring types is to use them for type annotations of the self-reference, and
creating instances. In the trait literature, a trait usually requires a set of
methods that server as parameters for the provided behaviour. In \name, the type
of \lstinline$self$ denotes what methods are required.

Creating an object is via the \lstinline{new} keyword, a convention in many OO
languages.
\lstinputlisting[linerange=12-12]{../examples/box.txt}% APPLY:linerange=POINT_TEST

\subsubsection{Inheriting Traits}

Traits are extensible. A trait can be extended by inheriting all members of
other traits, and defining additional members. This is, in some sense, similar
to class inheritance in traditional OO languages. However, one difference is
that, a trait can inherit one or more traits without any problems, provided that
there are no conflicts arising (cf. Section~\ref{sec:conflicts}).

To demonstrate that, we create another trait \lstinline$circle$ extending
\lstinline{point} with an extra method \lstinline{radius}.
\lstinputlisting[linerange=18-21]{../examples/box.txt}% APPLY:linerange=CIRCLE_DEF

Note here we use the intersection of type \lstinline{Point} and a record type to
model type \lstinline{Circle}. An intersection
type~\cite{dunfield2014elaborating} such as \lstinline{A & B} contains exactly
those values which can be used as values of type \lstinline{A} and of type
\lstinline{B}. As such, \lstinline{A & B} immediately introduces a subtyping
relation between itself and its two component types \lstinline{A} and
\lstinline{B}. Back to the above example, \lstinline{Circle} is a subtype of
\lstinline{Point}, unsurprisingly.

The keyword \lstinline{inherits} is one of the two options in \name to introduce
inheritance. In the above example, trait \lstinline{circle} inherits from trait
\lstinline{point} two methods \lstinline{x} and \lstinline{y} plus its own
method \lstinline{radius}. Now it is clear that, unlike the common covariant
model, \name separates the concept of subtyping from inheritance -- those two
concepts are not necessarily entangled, though in this particular example,
inheritance goes along with subtyping.

Next we represent buttons in the same way as points. Here are the trait of
buttons and its type:
\lstinputlisting[linerange=47-52]{../examples/box.txt}% APPLY:linerange=BUTTON_DEF

\subsubsection{Traits with Dependencies}

In our example, each graphical object can be decomposed into two aspects -- its
geometry and its functions. In case of circles, we already have a trait
\lstinline{circle} representing its geometry. We now proceed to define its
functions by another trait.
\lstinputlisting[linerange=29-38]{../examples/box.txt}% APPLY:linerange=CIRCLE_FNS

Note how in \lstinline$circleFns$ the type of the self-reference is
\lstinline$Circle$! This is in contrast to a typical object-oriented language,
such as Java, where the self-reference must always be of the same type as the
class being defined. It is this functionality that allows us to express
dependencies between traits: when \lstinline$circleFns$ is instantiated and
composed with other traits, they must be composed with an implementation of
\lstinline$Circle$.
\lstinputlisting[linerange=42-42]{../examples/box.txt}% APPLY:linerange=CIRCLE_FULL

The above line also shows the second option to introduce inheritance, namely by
\textit{composition} of traits. In other words, we can either compose beforehand
when declaring traits (using \lstinline{inherits}), or compose at object
creation point (using \lstinline{new} and \lstinline{&} operator).

Under the hood, inheritance is accomplished by using the \textit{merge operator}
(denoted by \lstinline{,,}). The merge operator~\cite{dunfield2014elaborating}
allows two arbitrary values to be merged, with the resulting type being an
intersection type. For example the type of \lstinline{2 ,, true} is
\lstinline{Int & Bool}. Back to the example, the use of merge enables us to call
methods from different traits on a single object, such as
\lstinline{circleWithFns.area()} and \lstinline{circleWithFns.radius}.

Similarly we define functions for buttons as well.
\lstinputlisting[linerange=56-63]{../examples/box.txt}% APPLY:linerange=BUTTON_FNS

It would be a shame if we cannot make a round button from the existing traits we
have! So here it is, trait \lstinline{roundButton} just inherits everything from
traits \lstinline{circle} and \lstinline{button}:
\lstinputlisting[linerange=67-69]{../examples/box.txt}% APPLY:linerange=ROUNDBUTTON_DEF

Next we add abilities to the round button on the fly and test its functionality
as follows:
\lstinputlisting[linerange=124-127]{../examples/box.txt}% APPLY:linerange=ROUNDBUTTON_TEST



\subsubsection{Detecting And Resolving Conflicts in Trait Composition}
\label{sec:conflicts}

A conflict arises if and only if we combine two traits that have identically
named methods. The traditional approach to resolve conflicts is by method
overriding, automatically done by the type system, whereas the trait-based
approach enforces conflicts be resolved on the level of the composition by the
programmers, otherwise the program is rejected by the type system. The following
example shows how conflicting methods in two traits are detected and resolved.

Let us introduce another shape: something oval.
\lstinputlisting[linerange=74-77]{../examples/box.txt}% APPLY:linerange=ASOVAL_DEF

The following trait gets rejected because both \lstinline{asOval} and
\lstinline{circle} have a conflicting \lstinline{radius} method.
\lstinputlisting[linerange=82-83]{../examples/box.txt}% APPLY:linerange=CONFLICT_DEF

Conflict detecting is one of the selling points of traits. In \name this feature
comes for free because of the requirement that intersection types are
\textit{disjoint}~\cite{oliveira2016disjoint}. Disjointness, in its simplest
form, means that the set of values of both types are disjoint. The above
problematic program fails at passing type checking precisely because both of the
traits (\lstinline{circle} and \lstinline{asOval}) have the same type of the
\lstinline{radius} method, thus violating the disjointness constraint.

To resolve the conflict, the programmer needs to explicitly state which
\lstinline{radius} gets to stay. \name provides such a means , the so-called
\textit{exclusion} operator (denoted by \lstinline{\}), which allows one to
avoid a conflict before it occurs. The following is one choice, and is accepted
by \name again.
\lstinputlisting[linerange=89-90]{../examples/box.txt}% APPLY:linerange=CONFLICT_RESOLVE



\subsection{Dynamic Instantiation}

One difference with traditional traits or classes is that traits in \name are
quite dynamic: we are able to compose traits \textit{dynamically} and then
instantiate them later. This is impossible in traditional OO language, such as
Java, since classes being instantiated must be known statically. In \name, as we
will explain in Section~\ref{sec:desugar}, traits are just terms: they are
first-class values and can be passed around or returned from a function.

Let us extend the functions of circles by another method \lstinline{inCircle},
which, given a point, tests if the point lies inside the circle.
\lstinputlisting[linerange=104-107]{../examples/box.txt}% APPLY:linerange=CIRCLE_FNS2

\lstinline{CircleFns2} just extends \lstinline{CircleFns} by another method
\lstinline{inCircle}, which, as shown in trait \lstinline{circleFns2}, is
implemented by invoking the \lstinline{norm} method from something of type
\lstinline{Circle & Norm}. So what is this \lstinline{Norm} type? It consists of
a single method \lstinline{norm} -- distance of a point to the origin . We
provide two different norms via two traits.
\lstinputlisting[linerange=94-100]{../examples/box.txt}% APPLY:linerange=NORM_DEF

To facilitate creating round buttons with different norms baked in, we define a
factory that takes a trait \lstinline$norm$ and produces a round button:
\lstinputlisting[linerange=111-113]{../examples/box.txt}% APPLY:linerange=POINT_FUNC

Here \lstinline{Trait} is a built-in keyword, and \lstinline$Trait[Point, Norm]$
is the type of traits that conforms to the \lstinline$Norm$ type with dependency
on \lstinline{Point}. It is worth noting that this kind of dynamic composition
and instantiation is impossible in traditional OO languages, such as Java,
because the concrete implementation of \lstinline{norm} is unknown at
compile-time, let alone compose it with other traits. This gives us the
flexibility to choose different norms. For example, below is another version of
round button that provides \lstinline{inCircle} method with Euclidean norm baked
in.
\lstinputlisting[linerange=117-117]{../examples/box.txt}% APPLY:linerange=ROUNDBUTTON_TEST2



\subsection{Extensibility and Subtyping}
\label{sec:extensibility}

Various solutions to the Expression Problem~\cite{wadler1998expression} in the
literature~\cite{finally-tagless,oliveira09modular,DelawareOS13,oliveira2012extensibility,
  swierstra:la-carte} are closely related to type-theoretic encodings of
datatypes. Indeed, variants of the same idea keep appearing in different
programming languages, because the encoding of the idea needs to exploit the
particular features of the programming language (or theorem prover).
Unfortunately language-specific constructs obscure the key ideas behind those
solutions. As our second running example, we presents \name's solution to the
Expression Problem that intends to capture the key ideas of various solutions in
the literature.

To start, we begin with a very simple system modeling arithmetic expressions and
evaluation. The initial system constitutes expressions with two variants
(literals and addition), as depicted below:
\lstinputlisting[linerange=4-7]{../examples/visitor.txt}% APPLY:linerange=ALGEBRA_DEF

The first part, captured by the type \lstinline{ExpAlg[E]}, constitutes the
so-called algebra of the datatype. The first component abstracts over the type
of literal expressions (\lstinline{Int -> E}). The second component abstracts
over the type of addition expression (\lstinline{E -> E -> E}).

The second part, which is the actual type of the arithmetic expression, is:
\lstinputlisting[linerange=11-11]{../examples/visitor.txt}% APPLY:linerange=CHURCH_DEF
An attentive reader may immediately recognize this is exactly the VISITOR
pattern: the method \lstinline{accept} takes an internal visitor as argument.

% \paragraph{Data constructors.} Using \lstinline{Exp} the two data constrcutors
% are defined as follows:
% \lstinputlisting[linerange=52-61]{../examples/visitor.txt}% APPLY:linerange=DC_DEF
% Note that the notation \lstinline{/\E} is type abstraction: it introduces a type
% variable in the environment.


\paragraph{Operations.} Defining operations over expressions requires
implementing \lstinline{ExpAlg[E]}. An interesting operation over expressions is
evaluation. The first step is to choose a suitable concrete type for
instantiating the type parameter \lstinline{E}. One such suitable type is:
\lstinputlisting[linerange=15-15]{../examples/visitor.txt}% APPLY:linerange=EVAL_DEF
Using \lstinline{IEval}, we can define a trait that implements the evaluation
rule for each variant:
\lstinputlisting[linerange=19-22]{../examples/visitor.txt}% APPLY:linerange=EVAL_IMPL


\paragraph{Add a subtraction variant.} Interesting things happen when a new
variant, such as subtraction is added. To do so, we need to extend both
\lstinline{ExpAlg[E]} and \lstinline{evalAlg}:
\lstinputlisting[linerange=27-31]{../examples/visitor.txt}% APPLY:linerange=SUB_DEF
Firstly, \lstinline{SubExpAlg[E]} defines an extended algebra that contains the
variants of the original plus the new subtraction variant. Intersection types
are used to model \textit{type inheritance}. Secondly, a new type of expressions
(\lstinline{ExtExp}) with subtraction is needed. It is important to note that
the \lstinline{accept} method now takes the new algebra \lstinline{SubExpAlg[E]}
as argument.

\paragraph{Inheritance is not subtyping.} In the presence of subtyping, there
are interesting subtyping relations between datatypes and their
extensions~\cite{oliveira09modular}. An interesting aspect about subtyping in
the new system is that subtyping follows the opposite direction of the
extension. In other words, subtyping is contravariant with respect to the
extension. First note that \lstinline{SubExpAlg[E]} appears in parameter
position of \lstinline{accept} and function parameters are naturally
contravariant: \lstinline{ExtExp} should be a \textit{supertype} of
\lstinline{Exp}. By contrast, in common OO languages, type inheritance and
subtyping always go along together. For example, Scala forbids any kind of
type-refinement on method parameter types. The consequence of this is that in
those languages, it is impossible to express that \lstinline{ExtExp} is both an
extension and a supertype of \lstinline{Exp}. Such kind of phenomena is an
example where ``inheritance is not subtyping''~\cite{cook1989inheritance}.

\paragraph{Add a new operation.} The second type of extension is adding a new
operation, such as pretty printing. Similar to evaluation, the interface of the
pretty printing feature is modeled as:
\lstinputlisting[linerange=37-37]{../examples/visitor.txt}% APPLY:linerange=PRINT_DEF
The implementation is spelled out straightforwardly:
\lstinputlisting[linerange=42-46]{../examples/visitor.txt}% APPLY:linerange=PRINT_IMPL


\paragraph{Usage.} The last piece is to define convenient data constructors:
\lstinputlisting[linerange=52-61]{../examples/visitor.txt}% APPLY:linerange=DC_DEF
So now we can test the shiny new system:
\lstinputlisting[linerange=66-70]{../examples/visitor.txt}% APPLY:linerange=VISITOR_EG
Notice that we are able to pass \lstinline{lit 5}, which is of type
\lstinline{Exp}, to \lstinline{sub}, which expects a value of type
\lstinline{ExtExp}. This works precisely because \lstinline{Exp} is a
\textit{subtype} of \lstinline{ExtExp}.



\subsection{How much dynamic is too much}
\label{sec:dynamic}

The solution to the Expression Problem presented in
Section~\ref{sec:extensibility} has one wrinkle in its usage. To be able to call
different operations from the same expression \lstinline{e}, we need to make two
copies \lstinline{o1} and \lstinline{o2}: one is used for printing, while the
other is used for evaluation. An ideal approach would be allowing a single object
to be created that supports both the printing and evaluation features.
Unfortunately, dynamic composition of algebras is non-trivial.
\citet{oliveira2012extensibility} addressed this problem by proposing
\textit{object algebra combinators} that combine multiple algebras into one.
However, as they noted, such combinators written in Java are difficult to use in
practice. A version of this combinator has been encoded in Scala using
intersection types and an encoding of the merge
operator~\cite{oliveira2013feature, rendel14attributes}. Again, the Scala
encoding of the merge operator is quite complex as it relies on low-level
type-unsafe programming features such as dynamic proxies, reflection or other
meta-programming techniques. In \name there is no need for such complex
encoding, as the merge operator is natively supported.

The combinator is defined by the \lstinline{combine} trait, which takes two
algebras to create a combined algebra. It does so by appropriately delegating
behaviours in each component algebra to the combined algebra.

\lstinputlisting[linerange=49-54]{../examples/visitor3.txt}% APPLY:linerange=COMBINE1_DEF

Something new is in the above trait declaration. \name supports parametric
polymorphism. In \name, type variables use uppercase letters. Following the work
of~\citet{alpuimdisjoint}, \name uses an extension to universal quantification
called \textit{disjoint quantification}, where a type variable can be
constrained so that it is disjoint with a given type (\lstinline{B * A} for
example). Parametric polymorphism is need because \lstinline{combine} must
compose algebras with arbitrary type parameters. A disjointness constraint is
needed to ensure that two input algebras build values of disjoint types
(otherwise ambiguity could arise).

With \lstinline{combine} at hand, we can finally have a object \lstinline{o}
print and evaluate at the same time:

\lstinputlisting[linerange=72-75]{../examples/visitor3.txt}% APPLY:linerange=COMBINE1_TEST

An acute reader may have smelled some boilerplate code in the definition of
\lstinline{combine}. After all, \lstinline{combine} just invokes the
corresponding method on the arguments, which is solely driven by the types of
the two input algebras and the resulting algebra. It turns out that the type
system behind \name is powerful enough to derive such definition for us:
\lstinline{combine} is no more than just the merge of two algebras!

\lstinputlisting[linerange=60-60]{../examples/visitor3.txt}% APPLY:linerange=COMBINE_DEF

That's it. No more boilerplate necessary. Two points worth noting: 1) \name
supports \textit{dynamic inheritance}. Notice how we let \lstinline{combine1}
``inherits'' \lstinline{f & g}, for which the implementation is unknown
statically. 2) \name supports multiple inheritance of traits with the same type:
both \lstinline{f} and \lstinline{g} are traits of the subtraction algebra.
Mainstream OO languages cannot even imagine being such dynamic and flexible.
\name hits a sweet spot in the design space of being how much dynamic, where we
retain as much flexibility as in a dynamic language without sacrificing the
type-safety guarantee we always love from a static type system.
