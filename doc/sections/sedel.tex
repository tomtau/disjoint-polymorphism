\section{A Tour of \name}

This section showcases the novel feature of \name, notably its native support
for dynamically composable traits. This is in contrast to the standard model of
class-based OOP, where subtyping is coupled with inheritance. We show that \name
overcomes all those limitations mentioned in Section~\ref{sec:critique}. All
examples shown in this section are runnable in our prototype implementation.


\subsection{Dynamically Composable Traits}
\label{sec:traits}

\name natively supports a simple, yet expressive form of dynamically composable
traits~\cite{scharli2003traits}. Traits provide a mechanism of code reuse in
object-oriented programming, that can be used as an alternative to multiple
inheritance. One interesting aspect about traits is the way conflicting features
that are typical arise in multiple inheritance are dealt with. Instead of
automatically resolved by scoping rules, conflicts are detected by the type
system, and require programmers to explicitly resolve them. In what follows, we
demonstrate various trait features in \name. A comparison with the traditional
trait model can be found in Section~\ref{sec:discuss}. The desugaring process
from traits to \bname is discussed in Section~\ref{sec:desugar}.

\subsubsection{Basic Traits}

A Trait is, in essential, a collection of related methods that characterize only
a specific perspective of the features of an object. Therefore, compared with
programs using inheritance, programs using traits usually have a large number of
small traits rather than fewer but larger classes. Code reuse with traits is
easier than with classes, since traits are usually shorter and can be
\textit{composed}. It is the ease of composition that makes traits such a
appealing language feature: two traits can be freely ``added'' together (which
is an symmetric operation); and trait systems provide conflict detection and so
on.

The first example shows basic trait composition. Many social networking sites
allow users to ``upvote'' a comment and the number of upvotes that comment has
received is also displayed. We would like to separate the logic for upvotes from
comments so that it can be reused in other entities. The code below defines a
trait, \lstinline$comment$, which contains a single method \lstinline$content$.

\lstinputlisting[linerange=4-7]{../examples/comment.txt}% APPLY:linerange=COMMENT_DEF

The syntax is very similar to Scala's, with the \lstinline{def} keyword
beginning a term declaration. Next we create another trait, \lstinline$up$, for
tracking the number of upvotes.

\lstinputlisting[linerange=12-15]{../examples/comment.txt}% APPLY:linerange=UP_DEF

At this point the reader may wonder what are those \lstinline{type} declarations
(\lstinline$Comment$ and \lstinline$Up$) for. In mainstream OO languages such as
Java, a class declaration such as \lstinline[language=java]$class C { ... }$ does two things at
the same time:

\begin{itemize}
\item Declaring a \textit{template} for creating object;
\item Declaring a new \textit{type}.
\end{itemize}

In contrast, trait declarations in \name only do the former. Back to our
example, the purpose of declaring two types is just to use them for type
annotations of the self-reference. In the trait literature, a trait usually
requires a set of methods that server as parameters for the provided behaviour.
In our example, the type of \lstinline$self$ denotes what methods are required.

Creating an object is via the \lstinline{new} keyword, a convention in many OO
languages, except for one crucial novelty: we can create an object from multiple
traits. More precisely, the object is created from the \textit{composition} of
those traits. Therefore, we are able to call methods from different traits on a
single object. For example, we can create an object from \lstinline$comment$ and
\lstinline$up$ and test its functionality as follows:

\lstinputlisting[linerange=20-22]{../examples/comment.txt}% APPLY:linerange=COMP_TEST

\subsubsection{Traits with Dependencies}

The following example shows that a trait can depend on another trait. We define
the type of a point and a trait for a standard point.

\lstinputlisting[linerange=5-9]{../examples/point.txt}% APPLY:linerange=POINT_DEF

The norm of a point can be defined as its distance to the origin. We provide two
definitions of norm via two traits\footnote{Due to the lack of full support for
  arithmetic operations, the definitions of Euclidean and Manhattan norms are
  ridiculously simplified. }.

\lstinputlisting[linerange=14-20]{../examples/point.txt}% APPLY:linerange=NORM_DEF

Note how in \lstinline$euclideanNorm$ and \lstinline$manhattanNorm$ the type of
the self-reference is \lstinline$Point$! This is in contrast to a typical
object-oriented language, such as Java, where the self-reference must always be
of the same type as the class being defined. It is this functionality that
allows us to express dependencies between traits: when \lstinline$euclideanNorm$
and \lstinline$manhattanNorm$ are instantiated and composed with some other
traits, they must be composed with an implementation of \lstinline$Point$.
\lstinputlisting[linerange=29-31]{../examples/point.txt}% APPLY:linerange=NORM_TEST

\subsubsection{Trait and Inheritance}

Traits in \name are extensible. A trait can be extended by inheriting all
members of other traits, and defining additional members. This is, in some
sense, similar to class inheritance in traditional OO languages. However, one
difference is that, a trait can inherits one or more traits without any
problems, provided that there are no conflicts arising.

Imagine we want to describe birds that can both fly and swim. For better reuse,
we define a trait that has the ability to swim:
\lstinputlisting[linerange=5-8]{../examples/birds.txt}% APPLY:linerange=SWIM_DEF
Similarly, here is a trait that has the ability to fly:
\lstinputlisting[linerange=13-16]{../examples/birds.txt}% APPLY:linerange=FLY_DEF
Now we are ready to describe a bird (duck) that can both fly and swim:
\lstinputlisting[linerange=20-23]{../examples/birds.txt}% APPLY:linerange=BIRD_DEF
Notice how trait \lstinline{duck} inherits the \lstinline{swim} and
\lstinline{fly} methods from trait \lstinline{swimming} and \lstinline{flying},
respectively. Here is how this super duck shows off it can both fly and swim:
\lstinputlisting[linerange=27-29]{../examples/birds.txt}% APPLY:linerange=BIRD_TEST


\subsubsection{Detecting Conflicts in Trait Composition}

A conflict arises if and only if we combine two traits that have identically
named methods. The traditional approach to resolve conflicts is by method
overriding, automatically done by the type system, whereas the trait-based
approach enforces conflicts be resolved on the level of the composition by the
programmers, otherwise the program is rejected by the type system. The following
example, adapted from~\citet{alpuimdisjoint}, shows how conflicting methods in
two traits are detected.

\lstinputlisting[linerange=17-27]{../examples/log.txt}% APPLY:linerange=CONFLICT_DEF

Here two traits \lstinline{person} and \lstinline{consoleLogger} are composed in
a variable \lstinline{jim}. It is type-safe to access both methods from
\lstinline{Person} and \lstinline{Loggable} in the object \lstinline{jim}.

If we have another trait \lstinline{dog}, and we mistakenly compose this with
\lstinline$person$, then the program is not accepted, due to both
\lstinline{Person} and \lstinline{Dog} sharing the same name (\lstinline{name})
and the same type (\lstinline$String$).

\lstinputlisting[linerange=6-13]{../examples/log.txt}% APPLY:linerange=CONFLICT_WRONG


\subsection{Extensibility and Subtyping}

Various solutions to the Expression Problem~\cite{wadler1998expression} in the
literature~\cite{finally-tagless,oliveira09modular,DelawareOS13,oliveira2012extensibility,
  swierstra:la-carte} are closed related to type-theoretic encoding of
datatypes. Indeed, variants of the same idea keep appearing in different
programming languages, because the encoding of the idea needs to exploit the
particular features of the programming language (or theorem prover).
Unfortunately language-specific constructs obscure the key ideas behind those
solutions. In this subsection, we presents \name's solution to the Expression
Problem that intends to capture the key ideas of various solutions in the
literature.

To start, we begin with a very simple system modeling arithmetic expressions and
evaluation. The initial system constitutes expressions with two variants
(literals and addition), as depicted below:
\lstinputlisting[linerange=4-7]{../examples/visitor.txt}% APPLY:linerange=ALGEBRA_DEF

The first part, captured by the type \lstinline{ExpAlg[E]}, constitutes the
so-called algebra of the datatype. The first component abstracts over the type
of literal expressions (\lstinline{Int -> E}). The second component abstracts
over the type of addition expression (\lstinline{E -> E -> E}).

The second part, which is the actual type of the arithmetic expression, is:
\lstinputlisting[linerange=11-11]{../examples/visitor.txt}% APPLY:linerange=CHURCH_DEF
Acute readers may immediately recognize this is exactly the visitor pattern: the
method \lstinline{accept} takes an internal visitor as argument.

% \paragraph{Data constructors.} Using \lstinline{Exp} the two data constrcutors
% are defined as follows:
% \lstinputlisting[linerange=52-61]{../examples/visitor.txt}% APPLY:linerange=DC_DEF
% Note that the notation \lstinline{/\E} is type abstraction: it introduces a type
% variable in the environment.


\paragraph{Operations.} Defining operations over expressions requires
implementing \lstinline{ExpAlg[E]}. An interesting operation over expressions is
evaluation. The first step is to choose a suitable concrete type for
instantiating the type parameter \lstinline{E}. One such suitable type is:
\lstinputlisting[linerange=15-15]{../examples/visitor.txt}% APPLY:linerange=EVAL_DEF
Using \lstinline{IEval}, we can define a trait that implements the evaluation
rule for each variant:
\lstinputlisting[linerange=19-22]{../examples/visitor.txt}% APPLY:linerange=EVAL_IMPL


\paragraph{Add a subtraction variant.} Interesting things happen when a new
variant, such as subtraction is added. To do so, we need to extend both
\lstinline{ExpAlg[E]} and \lstinline{evalAlg}:
\lstinputlisting[linerange=27-31]{../examples/visitor.txt}% APPLY:linerange=SUB_DEF
Firstly, \lstinline{SubExpAlg[E]} defines an extended algebra that contains the
variants of the original plus the new subtraction variant. Intersection types
are used to model \textit{type inheritance}. Secondly, a new type of expressions
with subtraction (\lstinline{ExtExp}) is needed. It is important to note that
the \lstinline{accept} method now takes the new algebra \lstinline{SubExpAlg[E]} as
argument.

\paragraph{Inheritance is not subtyping.} In the presence of subtyping, there
are interesting subtyping relations between datatypes and their
extensions~\cite{oliveira09modular}. The interesting aspect about subtyping in
the new system is that subtyping follows the opposite direction of the
extension. In other words, subtyping is contravariant with respect to the
extension. First note that \lstinline{SubExpAlg[E]} appears in parameter
position of \lstinline{accept} and function parameters are natually
contravariant: \lstinline{ExtExp} should be a \textit{supertype} of
\lstinline{Exp}. By contrast, in common OO languages, type inheritance and
subtyping always go along together. For example, Scala forbids any kind of
type-refinement on method parameter types. The consequence of this is that in
those languages, it is simply impossible to express that \lstinline{ExtExp} is
both an extension and a supertype of \lstinline{Exp}. Such kind of phenomena is
an example where ``inheritance is not subtyping''~\cite{cook1989inheritance}.

\paragraph{Add a new operation.} The second type of extension is adding a new
operation, such as pretty printing. Similar to evaluation, the interface of the
pretty printing feature is modeled as:
\lstinputlisting[linerange=37-37]{../examples/visitor.txt}% APPLY:linerange=PRINT_DEF
The implementation is spelled out straightforwardly:
\lstinputlisting[linerange=42-46]{../examples/visitor.txt}% APPLY:linerange=PRINT_IMPL


\paragraph{Usage.} The last piece is to define convenient data constructors:
\lstinputlisting[linerange=52-61]{../examples/visitor.txt}% APPLY:linerange=DC_DEF
So now we can test the shiny new system:
\lstinputlisting[linerange=66-69]{../examples/visitor.txt}% APPLY:linerange=VISITOR_EG
Notice that we are able to pass \lstinline{lit 5}, which is of type
\lstinline{Exp}, to \lstinline{sub}, which expects a value of type
\lstinline{ExtExp}. This works precisely because \lstinline{Exp} is a
\textit{subtype} of \lstinline{ExtExp}.



\subsection{Dynamic Instantiation of Traits}


\jeremy{ A composition operator combining two algebras at run-time,
  demonstrating the dynamic nature of trait instantiation, also show we can do
  multiple inheritance of things with the same type}
