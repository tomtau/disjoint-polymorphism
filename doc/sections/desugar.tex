\section{Desugaring and Implementation}
\label{sec:desugar}


The section provides the procedures of desugaring traits to \bname. The idea
behind trait translation is inspired by the functional mixin semantics using
open recursion, which is proposed by~\citet{cook1989denotational} in an untyped
setting. However, our translation is done in the context of a statically-typed
programming language, which is exactly why conflicts can be \textit{statically}
detected in traits.

\subsection{Trait Declarations}

Essentially traits are translated into term declarations, with methods becoming
record fields. The self reference is adjusted to be the last parameter of the
declaration. For example,
\begin{lstlisting}
  trait point(x : Int, y: Int) { self : Point =>
    def x() = x
    def y() = self.x()
  }
\end{lstlisting}
becomes
\begin{lstlisting}
  def point (x : Int) (y : Int) (self : Point) =
  { x = \_ -> x
  , y = \_ -> self.x()
  }
\end{lstlisting}

Note that if the target language has call-by-value semantics, the type of the
self reference would become a thunk, that is, \lstinline$T -> Point$, and every
use of \lstinline{self} would be replaced by \lstinline$self()$. Since we
purposely chose call-by-name semantics for the target language, this simplifies
a bit. Now it is clear that \lstinline{self} is not a special keyword: it can
have any name.

More formally, a trait of the form
\begin{lstlisting}[mathescape=true]
  trait m [$A_1$, ..., $A_n$] ($x_1 : A_1$, ..., $x_n : A_n$) inherits $a_1$ & ... & $a_n$ { s : $A_0$ =>
    def $m_1$(...) = $e_1$
    ...
    def $m_n$(...) = $e_n$
  }
\end{lstlisting}
is translated into a term declaration of the form
\begin{lstlisting}[mathescape=true]
  def m $A_1$ ... $A_n$ $(x_1 : A_1)$ ... $(x_n : A_n)$ $(s : A_0)$ = $a_1$(s) ,, ... ,, $a_n$(s) ,,
  {
    $m_1$ = \(...) -> $e_1$
  , ...
  , $m_n$ = \(...) -> $e_n$
  }
\end{lstlisting}


\subsection{Instantiations of Traits}

\name allows creating a single object from one or more traits. Specifically,
\lstinline{new} instantiates a trait by taking the fixpoint of its
corresponding open term. In fact, \lstinline{new} is translated as an inlined
fixpoint. For example,
\begin{lstlisting}
  new[Point] point(3,4)
\end{lstlisting}
becomes
\begin{lstlisting}
  let self : Point = point 3 4 self in self
\end{lstlisting}
Note that \name has built-in recursive let expressions.

The composition of traits in the \lstinline{new} expression is desugared using
the merge operator. Now it is clear that the reason traits have conflict
detection for free is that the merge operator is enforcing two terms being
merged are disjoint. For example,
\begin{lstlisting}
  new[Point & Norm] point(3,4) & euclideanNorm()
\end{lstlisting}
is turned into
\begin{lstlisting}
  let self : Point & Norm = (point 3 4 self) ,, (euclideanNorm () self) in self
\end{lstlisting}

Formally, a \lstinline{new} expression of the form
\begin{lstlisting}[mathescape=true]
  new[$A_1$ & ... & $A_n$] $a_1$ & ... & $a_n$
\end{lstlisting}
is translated into a let expression of the form
\begin{lstlisting}[mathescape=true]
  let self : $A_1$ & ... & $A_n$ = $a_1$(self) ,, ... ,, $a_n$(self) in self
\end{lstlisting}

\subsection{The Type for Traits}

\lstinline[mathescape=true]{Trait[$T_1, T_2$]} denotes the type of those traits
which provide an interface described by the type $T_2$ with dependency on $T_1$.
In fact, it is just like a type constructor except for the fact that it is
built-in in the language, and that the encoding is not exposed to the
programmers.

Formally, a trait type of the form
\begin{lstlisting}[mathescape=true]
  Trait[$T_1, T_2$]
\end{lstlisting}
becomes
\begin{lstlisting}[mathescape=true]
  $T_1$ -> $T_2$
\end{lstlisting}


\subsection{Implementation}

In the work by~\citet{alpuimdisjoint}, they chose System F as the target
language after translation. This is because later they need to prove type safety
of the translation. Since type safety of \bname has been proved, we chose
untyped lambda calculus as the execution model for the sake of efficiency.

\jeremy{add a diagram showing the pipeline of the implementation}