\section{Related Work}

\paragraph{(Disjoint) Intersection Types, Merge Operator}

There is a large body of work on studying intersection types. Dating back to
works as early as~\citet{coppo1981functional} and~\citet{pottinger1980type},
their motivation was to use intersection types to characterize exactly all
strongly normalizing lambda terms. Forsythe~\cite{reynolds1997design} is
probably the first practical programming language based on intersection types.
Since then various programming languages, including
CDuce~\cite{benzaken2003cduce}, Stardust~\cite{Dunfield07:Stardust}, Microsoft's
TypeScript, Redhat's Ceylon, Facebook's Flow, and Scala~\cite{scala-overview}
have incorporated some notion of intersection types.

The merge operator was first introduced in the Forsythe
language~\cite{reynolds1997design}. Recent work
by~\citet{dunfield2014elaborating} shows significant expressiveness of type
systems with intersection types and a merge operator. However their languages
all lack a important and desirable property of coherence. The limitation was
addressed by~\citet{oliveira2016disjoint}, where they introduce the notion of
disjointness to ensure coherence.

Previous work on incorporating polymorphism with intersection types includes
Pierce's $F_\wedge$~\cite{pierce1991programming2} and the recent work
by~\citet{Castagna:2014}. The former supports intersection types, polymorphism
and, as an extension, the merge operator. However $F_\wedge$ is incoherent due
to the use of such an extension. The latter is a coherent calculus with a
special merge operator that works on functions only. The \bname calculus,
proposed by~\citet{alpuimdisjoint} in their latest work, is the first coherent
calculus that includes parametric polymorphism, intersection types and a merge
operator. \bname serves the theoretical foundation of \name.


% \paragraph{Dynamically-typed Languages with Delegation Mechanism}

% \begin{itemize}
% \item Clojure Protocols
%   % http://www.ibm.com/developerworks/library/j-clojure-protocols/
% \item Ruby mixin
% \item JS mixin
% \end{itemize}

% They are all dynamically typed.

\paragraph{Delegation-based Languages, dynamically or statically}

\citet{lieberman1986using} is the first to promote the use of prototypes and
delegation as the mechanism to code sharing between objects.
SELF~\cite{chambers1991parents} is a dynamically typed, prototype-based
language. It offers a simple, pure, classless object model. SELF's inheritance
system supports a so-called \textit{prioritized multiple inheritance}. Parents
of a object are given priorities, with the higher-priory parents taking
precedence over the lower-priority parents if any names clashes. Parents of the
same priorities are unordered, and access to any clashing methods will generate
a ``messageAmbiguous'' error at run-time. Like (\jeremy{or unlike?}) \name, it
also support dynamic inheritance (which, in our terminology, should be called
mutable inheritance).

There is not much work on statically-typed, delegation-based languages.
\citet{kniesel1999type} provides a good overview of problems when combining
delegation with s static type discipline. Cecil~\cite{chambers1992object,
  chambers1993cecil} is a prototype-based language, inspired primarily by SELF,
where delegation is the mechanism for method call and code reuse. One of the
design goals of Cecil is to support multiple dispatching in a
data-abstraction-oriented programming style. Cecil supports a static type system
which is layered on top of the dynamically-typed core language, though no formal
typing rules are given. The type system supports parametric polymorphism, in
addition to the inclusion polymorphism supported through subtyping. Similar to
\name, the type check is able to detect statically when a message might be
ambiguously defined as a result of multiple inheritance or multiple dispatching.
However, one major omission of Cecil, which is also one of the interesting
features of \name, is dynamic inheritance. Like \name, Cecil clearly separates
inheritance of implementation and subtyping.

\citet{cook1989inheritance} are the first to propose a typed model of
inheritance where subtyping and inheritance are two separate concepts. In
particular, they introduce the notion of \textit{type inheritance} and show that
inherited objects have inherited types, not subtypes. An interesting aspect of
their model is the \textbf{with} construct, used to join two records. This is
somewhat similar to our merge construct. However two major differences are worth
pointing out: 1) the \textbf{with} construct operates only on records, and 2) it
is a biased operation, meaning the conflict is resolved by favoring values from
its right argument. This is in sheer contrast with \name, where the merge
construct allows merging two arbitrary terms of disjoint types to avoid
ambiguities. Because of the differences, their model are incapable to support
Javascript-stype mixin-based programming. Another difference is that recursive
types and F-bounded polymorphism are used to type object inheritance, while we
currently do not support recursive types.

\paragraph{Mixins and traits} \citet{bracha1990mixin}'s seminal paper extends
Modula-3 with mixins. Mixins are subclasses parameterized over a superclass, and
used to produce a variety of classes with the same functionality and behaviour.
Mixin-based inheritance requires that mixins be composed linearly, and as such,
conflicts are resolved implicitly (mixins appearing later overwrite all the
identically named features of earlier mixins). In comparison, the trait model in
\name requires conflicts be resolved explicitly.

\citet{flatt1998classes} proposed MIXEDJAVA, an extension to a subset of
sequential Java called CLASSICJAVA with mixins. In their model, mixins
completely subsume the role of classes (classes are mixins that do not inherit
any services). One interesting aspect in their system is that two identically
named methods are allowed to coexist, and are resolved at run-time with run-time
context information provided by the current \textit{view} of an object. In
comparison, conflicts in \name are detected statically, and resolved by the
programmers. Like \name, their model also enforces the distinction between
implementation inheritance and subtyping.

\jeremy{and more mixin-based languages?}


\begin{comment}

\begin{itemize}


\item ``Object-Oriented Multi-Methods in Cecil''

\item ``Dynamically composable collaborations with delegation layers''

\item ``Dimensions of Object-Based Language Design''

\item ``On the Semantic Diversity of Delegation-Based Programming Languages''

\item ``Self: The power of simplicity''

\item ``Type-safe delegation for run-time component adaptation''

\item ``A delegation-based object calculus with subtyping''

\item ``Can Addresses be Types? (a case study: objects with delegation)''

\item ``Inheritance is not subtyping''


Mixins

\item ``mixin-based inheritance''

\item ``Classes and mixins''

\item ``Jamâ€”Designing a Java Extension with Mixins''

\item ``Big Bang Designing a Statically-Typed Scripting Language''

\item ``Building a Typed Scripting Language''
  % https://jscholarship.library.jhu.edu/bitstream/handle/1774.2/39502/PALMER-DISSERTATION-2015.pdf?sequence=1&isAllowed=y

\item ``An imperative, first-order calculus with object extension''

\end{itemize}

Do they have polymorphic type systems? Do they support mutable self reference?

\end{comment}


\paragraph{Class-based Languages with More Advanced Form of Inheritance}

\citet{kniesel1999type} is the first to show that type-safe integration of
delegation with subtyping into a class-based model is possible, resulting in the
DARWIN model. In the DARWIN model, the type of the parent object must be a
declared class and this limits the flexibility of dynamic composition, whereas
in \name, the merge operator can merge/compose any objects. Another difference
with \name lies in the conflict resolution, where DARWIN relies on method
overriding with the assumption that the author of the overriding method is aware
of the effect.


Incomplete Featherweight Java (IFJ), proposed by \citet{bettini2008type}, is a
conservative extension of Featherweight Java with incomplete objects. Besides
standard classes, programmers can also define incomplete classes, whose
instances are incomplete objects. Incomplete objects can be composed (by object
composition) with complete objects, yielding new complete objects at run-time,
while ensuring statically that the composition is type safe. Incomplete classes
can declare some methods as ``incomplete'', either abstract or redefining, and
the body of these methods must be provided during object composition, which is
quite similar to traits with requirements in \name. However, object composition
in IFJ is quite restrictive, compared to \name, in that it can only compose a
incomplete object with a complete object, resulting in a new complete object.
Therefore two complete objects cannot be composed. IFJ support a sort of dynamic
inheritance since composition permits supplying at run-time the missing methods
with those of other objects. Similar to \name, subtyping and inheritance need
not to be connected (incomplete class inheritance does not imply subtyping). A
major difference with \name is that, though IFJ is type safe, it relies on a
special method body lookup strategy to resolve method name clashes. Lastly, the
type system is not polymorphic.



Figure~\ref{fig:comparision} shows the comparisons between \name and various
similar languages.

\begin{figure}[t]
  \centering
  \begin{tabular}{l|ccccc}
    \hline
    & \bf{Statically typed} & \bf{Polymorphism} & \bf{Covariant model} & \bf{Dynamic inheritance}  \\
    \hline
    \name & \cmark & \cmark & \xmark & \cmark \\
    \hline
    SELF & \xmark & \xmark & \xmark & \cmark \\
    \hline
    Cecil & \cmark & \cmark & \xmark & \xmark \\
    \hline
    IFJ & \cmark & \xmark & \xmark & \cmark \\
    % \hline
    % Scala & \cmark & \cmark & \cmark & \xmark \\
    % \hline
    % Java & \cmark & \cmark & \cmark & \xmark

  \end{tabular}
  \caption{Comparison between \name and various similar languages.}
  \label{fig:comparision}
\end{figure}




\begin{comment}

\begin{itemize}

\item Eiffel

\item ``Delegation by object composition'' (IFJ) and ``Type safe dynamic object delegation in class-based languages''


\item ``Nominal and Structural Subtyping in Component-Based Programming''

\item ``Object-Oriented Composition Untangled''
% \item https://pdfs.semanticscholar.org/7a0a/b7ffce1c1e1195832502d6cb7ace0646596e.pdf
\item ``Engineering a programming language: The type and class system of Sather ''

\item{``A prototypical java-like language with records and traits''}

\item ``A core calculus of classes and mixins''

\item ``A core calculus of higher-order mixins and classes''

\end{itemize}

\end{comment}
