\section{Applications}

This section shows the expressiveness of \name. We show that features of \name
(dynamically composable traits, intersection types, the merge operator,
parametric polymorphism and disjoint quantification) enable extensible designs
that have been presented in mainstream languages. In particular, \name addresses
limitations of those languages, making the designs significantly simpler. In
what follows, we preset a case study modularizing several orthogonal features of
a subset of JavaScript, used by~\citet{poplcook} in his undergraduate textbook
on programming languages. The case study illustrates that how various features
and operations can be modularly developed and later composed to assembly a
complete language with various operations baked in.

Figure~\ref{fig:mini-js} presents the syntax of the expressions, values and
types provided by the features with each line annotated with the corresponding
feature. For each feature, we also define three operations: evaluator, pretty
printer, and type checker.

\begin{figure}[t]
\centering
% \begin{small}
\begin{tabular}{lrclr}
  Expressions & $e$ & ::= & $[[N]] \mid [[e1 + e2]] \mid [[e1 - e2]] \mid [[e1 * e2]] \mid [[e1 / e2]] $ & $\mathit{Arith}$ \\
              && $\mid$ & $[[BL]] \mid [[e1 == e2]] \mid [[e1 < e2]] \mid$ $[[if e1 then e2 else e3]] $ & $\mathit{Bool}$\\
              && $\mid$ & $[[x]] \mid [[var x = e1 ; e2]]$  &  $\mathit{Var}$ \\
  Programs & $[[jpgm]]$ & ::= & $[[jdecl1 .. jdecln e]]$ & $\mathit{Function}$ \\
  Functions & $[[jdecl]]$ & ::= & $[[function f ( x : t ) { e }]]$ & \\
  Values & $v$ & ::= & $[[N]] \mid [[BL]]$ & \\
  Types  & $t$ & ::= & $[[int]] \mid [[bool]]$ &
\end{tabular}
% \end{small}
\caption{mini-JS expressions, values, and types}
\label{fig:mini-js}
\end{figure}

\subsection{The Base Language (Arith)}

We start with a very simple language of arithmetic expressions, as shown on the
left hand side of Figure~\ref{fig:base-lang}. The base language has features
such as literals, addition, subtraction among others. As with examples in
Section~\ref{sec:extensibility}, we use visitors to encode datatypes. The
right hand side of Figure~\ref{fig:base-lang} defines the interfaces of the
operations.

\begin{figure}[t]
  \centering
  \begin{tabular}{cc}
    \begin{subfigure}[t]{0.45\textwidth}
      \centering
      \lstinputlisting[linerange=137-146]{../examples/case_study1.txt}% APPLY:linerange=BASE_DEF
    \end{subfigure}
    &
    \begin{subfigure}[t]{0.45\textwidth}
      \centering
      \lstinputlisting[linerange=118-127]{../examples/case_study1.txt}% APPLY:linerange=INTERFACE
    \end{subfigure}
  \end{tabular}
  \caption{The base language (left) and the interfaces of the operations (right)}
  \label{fig:base-lang}
\end{figure}

\subsubsection{Evaluator}

The evaluation interface (\lstinline{IEval}) contains the \lstinline{eval}
method, which is a function from an evaluation environment (\lstinline{Env}) to
\lstinline{Maybe[Value]}. At this stage, the evaluation environment is not used,
but will be useful when we have variables. The evaluation of the base language
is quite straightforward, so we only show part of the code below:
\lstinputlisting[linerange=172-178]{../examples/case_study1.txt}% APPLY:linerange=BASE_EVALUATOR
To reduce boilerplate code when dealing with \lstinline{Maybe} values, like in
Haskell, we encode the bind operator \lstinline{bind} of the \lstinline{Maybe}
monad.

\subsubsection{Pretty printer and type checker}

Pretty printer and type checker are constructed in a similar manner, as is shown
in Figure~\ref{fig:printer} and~\ref{fig:checker}.

\begin{figure}[t]
  \centering
  \lstinputlisting[linerange=199-205]{../examples/case_study1.txt}% APPLY:linerange=PRETTY_BASE
  \caption{An object algebra for pretty printing. }
  \label{fig:printer}
\end{figure}

\begin{figure}[t]
  \centering
  \lstinputlisting[linerange=210-220]{../examples/case_study1.txt}% APPLY:linerange=TYPECHECKER_BASE
  \caption{An object algebra for type checking. }
  \label{fig:checker}
\end{figure}


\subsection{Adding Conditional Expressions (Bool)}

Now we extend the base language with conditional expressions.
\lstinputlisting[linerange=261-266]{../examples/case_study1.txt}% APPLY:linerange=CONDITIONAL
The augmented language now has Boolean literals, comparison features
(\lstinline{eq} and \lstinline{le}) and if expressions.

We omit the code of the operations as they follow the same pattern as we
described in Section~\ref{sec:extensibility}.

% Here is the extended evaluator. Now we need Boolean values.
% \lstinputlisting[linerange=-]{}% APPLY:linerange=EVALUATOR_CONDITIONAL
% Note that we didn't touch anything from \lstinline{evalArithAlg} but extend it
% to from a new evaluator. Now because the language can produce two kinds of
% values, it is worth noting that \lstinline{fromNum} (or \lstinline{fromBool}) is
% partial, meaning that it can diverge at run-time if the value is not a number
% (or Boolean). This is why we need a type checker to make sure such things cannot
% happen at run-time.

% Same goes for the pretty printer and the type checker.
% \lstinputlisting[linerange=-]{}% APPLY:linerange=PRETTY_CONDITIONAL
% \lstinputlisting[linerange=-]{}% APPLY:linerange=TYPECHECKER_CONDITIONAL



\subsection{Adding Variable Declarations (Var)}

Next we extend our language again with local variables and variable
declarations. We add two new constructors \lstinline{var} and \lstinline{decl}.
\lstinputlisting[linerange=367-370]{../examples/case_study1.txt}% APPLY:linerange=VARIABLE
For simplicity, we encode variables using strings. \lstinline{decl} takes three
arguments, the first is the variable to be declared, the second is the
expression bound with the variable, and the third is the body within which the
declared variable is in scope. Now the language is interesting enough to express
something like \lstinline{var x = 3; x + 1}.

The evaluator finally makes use of the evaluation environment, which is a
mapping from variables to values.
\lstinputlisting[linerange=388-394]{../examples/case_study1.txt}% APPLY:linerange=EVALUATOR_VARIABLE
For the variable case, we look it up in the environment to find its bound value.
For the declaration case, we evaluate the body expression in the augmented
environment.

We omit the code of pretty printer and type checker for the space reason.

\subsection{Adding Top-level Functions (Function)}

We add, as the final piece, top-level functions to the language. The only
extension is a call expression that takes a function name and an actual
argument expression\footnote{For simplicity, we only allow functions with one
  argument.}.
\lstinputlisting[linerange=422-427]{../examples/case_study1.txt}% APPLY:linerange=TOP_LEVEL

Top-level functions are collected into a function environment, a list of
bindings of function names to function definitions. A program is then a function
environment together with a main expression. We omit the code here, and refer an
interested reader to the supplementary materials.


\subsection{Putting All Together}

We hope by now the reader can share our feeling that this is indeed a modular
way to cook a language incrementally. We can of course continue in the same
fashion with more features and operations. We now stop to use the language to
make sure everything works as we expected.

First let us create a program that uses all the features the language supports
now.
\lstinputlisting[linerange=510-517]{../examples/case_study1.txt}% APPLY:linerange=FINAL_TEST
The concrete syntax of the program is shown in the comment above. We assume a
pre-defined function environment (\lstinline{fenv}) containing the definition of
the \lstinline{add1} function.

Now we can of course apply the operations to the program individually. Instead
of doing this, we go a step further -- we merge those three operations into one,
and apply the combined operation to the program. Here is a function that makes
sure ``well-typed programs cannot go wrong'':
\lstinputlisting[linerange=521-532]{../examples/case_study1.txt}% APPLY:linerange=SUPER_DEF
Note that \lstinline{superAlg} is the combined operation that has the ability to
type check, evaluate, and print a given program.

We apply it to the program we have just created:
\lstinputlisting[linerange=536-537]{../examples/case_study1.txt}% APPLY:linerange=TEST_TEST
Everything works as expected!
