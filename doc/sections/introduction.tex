\section{Introduction}
\label{sec:intro}
\bruno{Jeremy please go over and fill in the missing references.}

Mainstream statically-typed Object-Oriented Programming (OOP) languages (such as Java,
C++ C\# or Scala) all use a similar programming model based on
classes. This programming model has its roots on the
origins of OOP in the 1960's in the Simula~\cite{dahl1967simula} language.
We will refer to this model as the \emph{covariant model} for the
remainder of this paper, because in this model inheritance and
subtyping vary in the same way. More concretely
the following is expected in the covariant model:

\begin{itemize}

\item {\bf Extensions always produce subtypes:} In the standard model, when a 
subclass \emph{extends} a class it automatically becomes a 
\emph{subtype} of the super-class. 

\item{\bf Inheritance and subtyping go along together:}
Class extension does two things at once: it inherits code from the
superclass; and it creates a subtype. 

\end{itemize}

The covariant model has been sucessefully used for over 50 years,
so it clearly has demonstrated its value in practice. 
Part of this success can probably be attributed 
to its relative simplicity. In particular, programmers do not have to think carefully 
about the difference between subtyping and inheritance (indeed many
programmers confuse the two concepts). 

Nevertheless the study of the theoretical foundations has
taught us that the story about OOP is not quite so simple. Since the
earliest works on the theory of OOP and subtyping, we have known that 
the covariant view of objects is somewhat simplified. Already in
Cardelli's~\cite{}\bruno{missing ref.} earliest work on the theoretic foundations of OOP,
we knew that functions do not behave in a strictly covariant way. 
However it was only until \citet{cook1989inheritance}'s famous paper on
``\emph{Inheritance is not Subtyping}'' that the issues were discussed 
in more detail. As Cook et al. argued inheritance and
subtyping are different relations: subtyping being a relation on types 
and inheritance being a relation on objects. In the covariant model 
the subtype relation is based on the inheritance hierarchy. This 
works very well if extensions produce 
subtypes. However, as Cook et al.'s work famously demonstrated 
this is not always the case. The essential implication of this is that
the covariant model cannot express well programs where inheritance 
and subtyping do not go along together. Following their observations about 
inheritance and subtyping, Cook et al. suggest a more general and 
flexible programing model (which we call the \emph{flexible model}) with the following properties:

\begin{itemize}

\item {\bf Inheritance and subtyping should be decoupled:} 
That is, there should be different mechanisms for class inheritance 
and class/interface subtyping. 

\item {\bf Extensions do not always produce subtypes:} 
There are cases where classes can inherit from other classes without 
producing subtypes. 

\end{itemize}


\begin{comment}
Cardelli's work on calculi for OOP has shown, for example, that
functions are not strictly covariant.  A function of type $A \to B$ is
a subtype of another function $C \to D$ when $B$ is a subtype of $D$
and $A$ is a \emph{supertype} of $C$. This means, for example that a
function of type $Cat \to Int$ \emph{cannot not be subtype} of a
function with type $Animal \to Int$ (assumming that $Cat$ is a subtype
of $Animal$). In fact, only the opposite can
happen: $Animal \to Int$ can be a subtype of $Cat \to Int$.  This is
at odds with the covariant view. Most mainstream OOP languages, such as Java or C\#, address this
disturbance of the covariant view by making methods \emph{invariant} on 
their argument types. In other words, if a class $A$ with method $m$
extends a class $B$ with method $m$, then $A.m$ can only override 
$B.m$ if the parameters types in both method signatures are \emph{exactly 
the same}. Thus mainstream OOP languages restrict the natural subtyping of
functions. Various other issues related to covariance are known. 
For example...

Cook et al.'s work on ``\emph{Inheritance is not Subtyping}''~\cite{}
is another example of how the theory of  OOP languages contradicts 
the simple covariant model. As Cook et al. argued inheritance and
subtyping are different relations: subtyping being a relation on types 
and inheritance being a relation on objects. In the covariant model 
the subtype relation is based on the inheritance hierarchy. This 
works very well if extensions produce 
subtypes. However, as Cook et al.'s work famously demonstrated 
this is not always the case. The essential implication of this is that
the covariant model cannot express programs that do not follow the 
covariant view of objects well. Following their observations about 
inheritance and subtyping, Cook et al. suggest a more general and 
flexible programing model (which we call the \emph{flexible model}) with the following properties:

\begin{itemize}

\item {\bf Inheritance and subtyping should be decoupled:} 
That is, there should be different mechanisms for class inheritance 
and class/interface subtyping. 

\item {\bf Extensions do not always produce subtypes:} 
There are cases where classes can inherit from other classes without 
producing subtypes. 

\end{itemize}

\end{comment}

Despite being proposed almost 30 years ago, and one of the most
famous papers in OOP, Cook et al.'s paper has not had much impact 
on the design of mainstream OOP languages (although it has influenced 
the design of several academic languages~\cite{}~\bruno{references}).
%Certainly this is not because
%researchers or designer of OOP language are unaware of the subtleties 
%of covariance and contravariance. Indeed over the years, and for other
%reasons various features have been added to programming languages to 
We believe that there are two primary reasons for the lack of adoption
of their model.  Firstly, the mental programming model is not
as simple as the covariant model. In the flexible model programmers have to
think more carefully on whether extensions produce subtypes or not,
for example.  Thus, it is crutial for programmers to understand the
difference between subtyping and inheritance.
Secondly, and perhaps more importantly, there are not many compelling applications in
the literature where the need for a more flexible OOP model is
necessary. Thus language designers may argue that the costs outweight 
the benefits, and may decide to stick instead to the covariant 
model, which is simple, and well-understood by programmers. 
%Indeed a famous instance of this is the design of DART

This paper has three primary goals. The first goal is to argue that the
covariant model significantly restricts statically-typed OOP programming in
terms of modularity and reuse for important practical applications. The second
goal to identify additional desirable features that improve flexibility of OOP
and are needed in practice. In particular we argue that supporting a more
\emph{dynamic} form of inheritance (where concrete implementations of the
inherited code are possibly unknown) is highly desirable in practice. Thus we
are naturally led to a OO language design using \emph{delegation} (or
\emph{dynamic inheritance}). Finally, we present \name: a purely functional OO
language that puts these ideas into practice using a polymorphic structural type
system based on \emph{disjoint intersection types}~\cite{oliveira2016disjoint}
and \emph{disjoint polymorphism}~\cite{alpuimdisjoint}. The choice of structural
typing is just due to simplicity, but we think similar ideas should also work
in a nominal type system.

Regarding the first goal, we show that the inflexibility of type systems of
mainstream statically-typed OOP languages is problematic for
\emph{extensible designs}.
There has been a remarkable number of works aimed at improving support
for extensibility in programming languages
~\cite{Prehofer97,Tarr99ndegrees,Harrison93subject,McDirmid01Jiazzi,Aracic06CaesarJ,Smaragdakis98mixin,nystrom2006j,togersen:2004,Zenger-Odersky2005,oliveira09modular,oliveira2012extensibility}. 
Some of the more recent work on extensibility is focused on design
patterns such as Extensible
Visitors~\cite{togersen:2004,oliveira09modular} or Object Algebras
\cite{oliveira2012extensibility}. 
Although such design patterns give practical benefits in terms of
extensibility, they also expose limitations in existing mainstream OOP
languages. In particular there are two problematic issues:

\begin{enumerate}

\item {\bf Visitor/Object-Algebra extensions produce supertypes:}
  Since in the covariant model extensions always produce subtypes, it
  is impossible to correctly express the subtyping relations between
  Visitor and Object Algebra extensions and the original types.

\item {\bf Object Algebra combinators require a very flexible form of
    dynamic inheritance:} As shown by Oliveira et al. and Rendel et
  al.~\cite{oliveira2013feature,rendel14attributes}, Object Algebra
  combinators, which allow a very flexible form of composition for
  Object Algebras, requires features not available in languages like
  Java or Scala.

\end{enumerate}

It is clear that an obvious way to solve the first issue is to 
move away from the covariant model, and this is precisely what \name does. 
For the second issue, \citet{oliveira2013feature,rendel14attributes}
do show how to encode Object Algebra combinators in mainstream
languages. However, this requires the
use of low-level (type-unsafe) reflection techniques, such as dynamic proxies,
reflection or other forms of meta-programming. It is clear
that better language support would be desirable. \name does 
this by embracing delegation, and having a powerful polymorphic type
system with intersection types and disjoint polymorphism. \name type
system is capable of statically-type checking the code for 
delegation-based Object Algebra combinators and their uses.

\paragraph{paragraph on the relation between \name and disjoint
  intersection types}

In summary the contributions of this paper are:

\begin{itemize}

\item \name: a type-safe and coherent OO language supporting dynamic
inheritance.

\item An illustration of applications that utilize \name's type system 
for improved modularity and extensibility.

\item Thin-layer of sugar on top of disjoint intersection types and
  polymorphism.

\end{itemize}

\begin{comment}

\paragraph{\bf JavaScript-style Mixin-Based Programming}
A common programming pattern in JavaScript is based on a variant of
Mixins. This programming style is very flexible and enables forms 
of reuse not usually available in more statically typed languages like Java.
However, mixins in JavaScript fundamentally rely on an \emph{object-level composition}
operator for inheritance~\cite{}. This requires a very dynamic form of
inheritance/delegation that is not available in most class-based 
statically-typed OO languages. Ideally the essence of such 
form of mixins should be capturable in statically-typed languages. 
Languages such as TypeScript do attempt to provide better static
type-checking support for those patterns. However, as recently illustrated 
by the work of \citet{alpuimdisjoint}, there are several issues with such an
approach, including type-unsoundness!

\end{comment}