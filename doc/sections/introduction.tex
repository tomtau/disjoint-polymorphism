\section{Introduction}

Mainstream statically-typed Object-Oriented Programming (OOP) languages (such as Java,
C++ C\# or Scala) all use a similar programming model based on
classes. For the remainder of the paper this will be referred to as
the \emph{standard model}. The standard model has its roots on the
origins of OOP in the 1960's in the Simula~\cite{} language. 
The standard model essentially provides a \emph{covariant} view of
objects, where the following basic properties are expected:
\bruno{are the two below essentially the same?}

\begin{itemize}

\item {\bf Extensions produce subtypes:} In the standard model, when a 
subclass \emph{extends} a class it automatically becomes a 
\emph{subtype} of the super-class. 

\item{\bf Inheritance and subtyping go along together:}
Class extension does two things at once: it inherits code from the
superclass; and it creates a subtype. In other words inheritance and
subtyping always go along together. 

\end{itemize}

The standard model has been sucessefully being used for over 50 years,
so it clearly has demonstrated its value in practice. In our personal
opinion this success can be attributed to a few things. Firstly,
subtyping and inheritance enable forms of reusability and modularity 
that are not easily or naturally available in languages without such
mechanisms. Secondly, the model is relatively simple and intuitive 
to grasp for programmers. \bruno{more?}

Unfortunatelly the study of the theoretical foundations has
taught us that the story about OOP is not quite so simple. Since the
earliest works on the theory of OOP and subtyping, we have known that 
the covariant view of objects is somewhat simplified. 

Cardelli's work on calculi for OOP has shown, for example, that
functions are not strictly covariant.  A function of type $A \to B$ is
a subtype of another function $C \to D$ when $B$ is a subtype of $D$
and $A$ is a \emph{supertype} of $C$. This means, for example that a
function of type $Cat \to Int$ \emph{cannot not be subtype} of a
function with type $Animal \to Int$ (assumming that $Cat$ is a subtype
of $Animal$). In fact, only the opposite can
happen: $Animal \to Int$ can be a subtype of $Cat \to Int$.  This is
at odds with the covariant view. Mainstream OOP languages such as Java or C\# address this
disturbance of the covariant view by making methods \emph{invariant} on 
their argument types. In other words, if a class $A$ with method $m$
extends a class $B$ with method $m$, then $A.m$ can only override 
$B.m$ if the parameters types in both method signatures are \emph{exactly 
the same}. Thus mainstream OOP languages restrict the natural subtyping of
functions. Various other issues related to covariance are known. 
For example...

Cook et al.'s work on ``\emph{Inheritance is not Subtyping}''~\cite{}
is another example of how the theory of  OOP languages contradicts 
the simple covariant model. As Cook et al. argued inheritance and
subtyping are different relations: subtyping being a relation on types 
and inheritance being a relation on objects. In the standard model 
the subtype relation is based on the inheritance hierarchy. This 
would work very well if extensions would \emph{always} produce 
subtypes. However, as Cook et al.'s work famously demonstrated 
this is not always the case. Following their observations about 
inheritance and subtyping, Cook et al. suggest a programing model 
with the following properties:

\begin{itemize}

\item {\bf Inheritance and subtyping should be decoupled:} 
That is, there should be different mechanisms for class inheritance 
and class/interface subtyping. 

\item {\bf Extensions do not always produce subtypes:} 
There are cases where classes can inherit from other classes without 
producing subtypes. 

\end{itemize}

Therefore Cook et al's model does away with the simple-minded covariant 
view of objects, and proposes a more general model

Despite being proposed almost 30 years ago, and one of the most
famous papers in OOP, Cook et al.'s paper has not had much impact 
on the design of OOP languages. A possible explanation for this 


There are multiple flavours of inheritance. To avoid confusion, since 
the same terminology is often used in the literature to mean different 
things, we use the following 3 terms in this paper:

\begin{itemize}



\item{{\bf Static inheritance:}} Static inheritance refers to what the
  typical model of inheritance in class-based languages. The
  inheritance model is said to be static because when using class
  extension, the extended classes are statically known at compile-type.
Static inheritance is used in languages such as Java, Scala or C\# or
C++\footnote{Note that C++ templates allow the Mixin pattern, which
  enables ...}.

\item{{\bf Mutable Inheritance:}} Prototype-based languages such as 
Javascript or Self allow another model of inheritance, which we call
\emph{mutable inheritance}. In this inheritance model, self references 
can be changed at any point. 

\item{{\bf Dynamic Inheritance:}} Dynamic inheritance is a less well-known 
model which stands in between static and mutable inheritance.
Dynamic inheritance is a model used by some academic delegation 
OOP languages, such as ...  
Unlike the static inheritance model, with dynamic inheritance 
objects can inherits from other objects which are not statically
known. However, unlike mutable inheritance, the self-reference is not 
mutable and cannot be arbitrarely changed at run-time. 

\end{itemize}

