
\section{A Tour of \name}
\label{sec:traits}

This section showcases the novel features of \name, notably its native support
for dynamically composable traits. We demonstrate that \name overcomes all those
limitations mentioned in Section~\ref{sec:critique}.

We describe a representation of graphical objects such as circles, ovals, or
buttons as our running example. The example is adapted from a blog
post\footnote{\url{https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/}}.
We will use traits to structure the representation and factor out reusable
components. Along the way, we also explain briefly how various features in \name
are encoded behind the scene. All code snippets in this section are runnable in
our prototype implementation.


\subsection{Dynamically Composable Traits}

\name natively supports a simple, yet expressive form of dynamically composable
traits~\cite{scharli2003traits}. Traits provide a mechanism of code reuse in
object-oriented programming, that can be used as an alternative to multiple
inheritance. One interesting aspect about traits is the way conflicting features
that are typical arise in multiple inheritance are dealt with. Instead of
automatically resolved by scoping rules, conflicts are detected by the type
system, and require programmers to explicitly resolve them. In what follows, we
demonstrate various trait features in \name. A comparison with the traditional
trait model can be found in Section~\ref{sec:discuss}. The desugaring process
from traits to \bname is discussed in Section~\ref{sec:desugar}.

\subsubsection{Specifying Traits}

A Trait is, in essential, a collection of related methods that characterize only
a specific perspective of the features of an object. Therefore, compared with
programs using inheritance, programs using traits usually have a large number of
small traits rather than fewer but larger classes. Code reuse with traits is
easier than with classes, since traits are usually shorter and can be
\textit{composed}. It is the ease of composition that makes traits such a
appealing language feature: two traits can be freely ``added'' together (which
is an symmetric operation); and trait systems provide conflict detection, etc.

Here is a simple trait \lstinline{point} with its two coordinates \lstinline{x}
and \lstinline{y}.
\lstinputlisting[linerange=4-8]{../examples/box.txt}% APPLY:linerange=POINT_DEF
The syntax is very similar to Scala's, with the \lstinline{def} keyword
beginning a term declaration.

At this point the reader may wonder what is the \lstinline{type} declaration
(\lstinline$Point$) for. In mainstream OO languages such as Java, a class
declaration such as \lstinline[language=java]$class C { ... }$ does two things
at the same time:

\begin{itemize}
\item Declaring a \textit{template} for creating object;
\item Declaring a new \textit{type}.
\end{itemize}

In contrast, trait declarations in \name only do the former. The purpose of
declaring types is to use them for type annotations of the self-reference, and
creating instances. In the trait literature, a trait usually requires a set of
methods that server as parameters for the provided behaviour. In \name, the type
of \lstinline$self$ denotes what methods are required.

Creating an object is via the \lstinline{new} keyword, a convention in many OO
languages.
\lstinputlisting[linerange=12-12]{../examples/box.txt}% APPLY:linerange=POINT_TEST

\subsubsection{Inheriting Traits}

Traits are extensible. A trait can be extended by inheriting all members of
other traits, and defining additional members. This is, in some sense, similar
to class inheritance in traditional OO languages. However, one difference is
that, a trait can inherit one or more traits without any problems, provided that
there are no conflicts arising (cf. Section~\ref{sec:conflicts}).

To demonstrate that, we create another trait \lstinline$circle$ extending
\lstinline{point} with an extra method \lstinline{radius}.
\lstinputlisting[linerange=18-21]{../examples/box.txt}% APPLY:linerange=CIRCLE_DEF

Note here we use the intersection of type \lstinline{Point} and a record type to
model type \lstinline{Circle}. An intersection
type~\cite{dunfield2014elaborating} such as \lstinline{A & B} contains exactly
those values which can be used as values of type \lstinline{A} and of type
\lstinline{B}. As such, \lstinline{A & B} immediately introduces a subtyping
relation between itself and its two component types \lstinline{A} and
\lstinline{B}. Back to the above example, \lstinline{Circle} is a subtype of
\lstinline{Point}, unsurprisingly.

The keyword \lstinline{inherits} is one of the two options in \name to introduce
inheritance. In the above example, trait \lstinline{circle} inherits from trait
\lstinline{point} two methods \lstinline{x} and \lstinline{y} plus its own
method \lstinline{radius}. Now it is clear that, unlike the common covariant
model, \name separates the concept of subtyping from inheritance -- those two
concepts are not necessarily entangled, though in this particular example,
inheritance goes along with subtyping.

Next we represent buttons in the same way as points. Here are the trait of
buttons and its type:
\lstinputlisting[linerange=47-52]{../examples/box.txt}% APPLY:linerange=BUTTON_DEF

\subsubsection{Traits with Dependencies}

In our example, each graphical object can be decomposed into two aspects -- its
geometry and its functions. In case of circles, we already have a trait
\lstinline{circle} representing its geometry. We now proceed to define its
functions by another trait.
\lstinputlisting[linerange=29-38]{../examples/box.txt}% APPLY:linerange=CIRCLE_FNS

Note how in \lstinline$circleFns$ the type of the self-reference is
\lstinline$Circle$! This is in contrast to a typical object-oriented language,
such as Java, where the self-reference must always be of the same type as the
class being defined. It is this functionality that allows us to express
dependencies between traits: when \lstinline$circleFns$ is instantiated and
composed with other traits, they must be composed with an implementation of
\lstinline$Circle$.
\lstinputlisting[linerange=42-42]{../examples/box.txt}% APPLY:linerange=CIRCLE_FULL

The above line also shows the second option to introduce inheritance, namely by
\textit{composition} of traits. In other words, we can either compose beforehand
when declaring traits (using \lstinline{inherits}), or compose at object
creation point (using \lstinline{new} and \lstinline{&} operator).

Under the hood, inheritance is accomplished by using the \textit{merge operator}
(denoted by \lstinline{,,}). The merge operator~\cite{dunfield2014elaborating}
allows two arbitrary values to be merged, with the resulting type being an
intersection type. For example the type of \lstinline{2 ,, true} is
\lstinline{Int & Bool}. Back to the example, the use of merge enables us to call
methods from different traits on a single object, such as
\lstinline{circleWithFns.area()} and \lstinline{circleWithFns.radius}.

Similarly we define functions for buttons as well.
\lstinputlisting[linerange=56-63]{../examples/box.txt}% APPLY:linerange=BUTTON_FNS

It would be a shame if we cannot make a round button from the existing traits we
have! So here it is, trait \lstinline{roundButton} just inherits everything from
traits \lstinline{circle} and \lstinline{button}:
\lstinputlisting[linerange=67-69]{../examples/box.txt}% APPLY:linerange=ROUNDBUTTON_DEF

Next we add abilities to the round button on the fly and test its functionality
as follows:
\lstinputlisting[linerange=124-127]{../examples/box.txt}% APPLY:linerange=ROUNDBUTTON_TEST



\subsubsection{Detecting And Resolving Conflicts in Trait Composition}
\label{sec:conflicts}

A conflict arises if and only if we combine two traits that have identically
named methods. The traditional approach to resolve conflicts is by method
overriding, automatically done by the type system, whereas the trait-based
approach enforces conflicts be resolved on the level of the composition by the
programmers, otherwise the program is rejected by the type system. The following
example shows how conflicting methods in two traits are detected and resolved.

Let us introduce another shape: something oval.
\lstinputlisting[linerange=74-77]{../examples/box.txt}% APPLY:linerange=ASOVAL_DEF

The following trait gets rejected because both \lstinline{asOval} and
\lstinline{circle} have a conflicting \lstinline{radius} method.
\lstinputlisting[linerange=82-83]{../examples/box.txt}% APPLY:linerange=CONFLICT_DEF

Conflict detecting is one of the selling points of traits. In \name this feature
comes for free because of the requirement that intersection types are
\textit{disjoint}~\cite{oliveira2016disjoint}. Disjointness, in its simplest
form, means that the set of values of both types are disjoint. The above
problematic program fails at passing type checking precisely because both of the
traits (\lstinline{circle} and \lstinline{asOval}) have the same type of the
\lstinline{radius} method, thus violating the disjointness constraint.

To resolve the conflict, the programmer needs to explicitly state which
\lstinline{radius} gets to stay. \name provides such a means , the so-called
\textit{exclusion} operator (denoted by \lstinline{\}), which allows one to
avoid a conflict before it occurs. The following is one choice, and is accepted
by \name again.
\lstinputlisting[linerange=89-90]{../examples/box.txt}% APPLY:linerange=CONFLICT_RESOLVE



\subsection{Dynamic Instantiation}

One difference with traditional traits or classes is that traits in \name are
quite dynamic: we are able to compose traits \textit{dynamically} and then
instantiate them later. This is impossible in traditional OO language, such as
Java, since classes being instantiated must be known statically. In \name, as we
will explain in Section~\ref{sec:desugar}, traits are just terms: they are
first-class values and can be passed around or returned from a function.

Let us extend the functions of circles by another method \lstinline{inCircle},
which, given a point, tests if the point lies inside the circle.
\lstinputlisting[linerange=104-107]{../examples/box.txt}% APPLY:linerange=CIRCLE_FNS2

\lstinline{CircleFns2} just extends \lstinline{CircleFns} by another method
\lstinline{inCircle}, which, as shown in trait \lstinline{circleFns2}, is
implemented by invoking the \lstinline{norm} method from something of type
\lstinline{Circle & Norm}. So what is this \lstinline{Norm} type? It consists of
a single method \lstinline{norm} -- distance of a point to the origin . We
provide two different norms via two traits.
\lstinputlisting[linerange=94-100]{../examples/box.txt}% APPLY:linerange=NORM_DEF

To facilitate creating round buttons with different norms baked in, we define a
factory that takes a trait \lstinline$norm$ and produces a round button:
\lstinputlisting[linerange=111-113]{../examples/box.txt}% APPLY:linerange=POINT_FUNC

Here \lstinline{Trait} is a built-in keyword, and \lstinline$Trait[Point, Norm]$
is the type of traits that conforms to the \lstinline$Norm$ type with dependency
on \lstinline{Point}. It is worth noting that this kind of dynamic composition
and instantiation is impossible in traditional OO languages, such as Java,
because the concrete implementation of \lstinline{norm} is unknown at
compile-time, let alone compose it with other traits. This gives us the
flexibility to choose different norms. For example, below is another version of
round button that provides \lstinline{inCircle} method with Euclidean norm baked
in.
\lstinputlisting[linerange=117-117]{../examples/box.txt}% APPLY:linerange=ROUNDBUTTON_TEST2
