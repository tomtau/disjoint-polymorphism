\section{A Critique of Mainstream Statically-Typed OOP}
\label{sec:critique}

This section discusses several limitations of mainstream OOP languages
that work against modularity and reuse. 
Such limitations arize from the
\emph{covariant model} of objects, the limitations imposed by the use
of \emph{static inheritance} and common (overly conservative) 
\emph{restrictions} imposed to inheritance mechanisms.
Our discussion serves as a critique to the mechanisms present in
current mainstream statically-typed OOP languages, and it is  
a motivator for the design of \name. However, independently of our work on \name, 
the critique is useful to pinpoint drawbacks that could be addressed
differently in future work by others.

\begin{comment}
 In particular we argue that in the
standard model of class-based OOP is grounded on the following 
assumptions:

\begin{itemize}

\item {\bf The covariant view of objects:} 

\item {\bf The view that extensions lead to subtypes:}

\item {\bf }

\end{itemize}

Those points were a driver for the
design of \name, which aims to address all of those limitations. 

\subsection{The Standard Model of Class-Based OOP}

In the standard statically typed OOP model for class-based languages
\emph{extensions} (subclasses or subinterfaces) are viewed as \emph{subtypes} of the original
class/interface. Moreover subclasses inherit from the superclasses,
and inheritance and subtyping always go along together.
This is the model adopted by most popular mainstream
languages, such as Java, C\#, C++ or Scala. This model can be traced
back to the origins of OOP in Simula~\cite{}, and has shown an 
undeniable resiliance through times. One reason why this model remains 
so popular is probably simplicity: 
extensions (of classes or interfaces) always result in subtypes.  
This results in a very simple programming model, which is easy 
to explain to programmers.  

Unfortunatelly, as the theory of OOP languages and subtyping has taught 
us that the story is not quite so simple. Since the early days of the
theoretical foundations of OOP and subtyping, it has bee

Early on Cook et al. argued
that {\bf Inheritance is not Subtyping}. \ldots
\end{comment}

\subsection{No Retroactive Super Types and Contravariant Subtyping Refinement}

In the covariant model extensions are always subtypes. However, as we
shall see, there are situations where extensions are actually
\emph{supertypes}. Unfortunatelly this is not supported in the
covariant model. Using some imaginary syntax for a Java-like language, 
what we would like to express is:

\begin{lstlisting}[language=java]
interface B {}   // original interface

interface A super B {} // A interface added later, which becomes a supertype of B
\end{lstlisting}

\noindent We call such an imaginary feature \emph{retroactive super
  types}. The feature is said to be retroactive because supertypes can
be added \`a posteriori, which is not possible in languages like Java.

Retroactive super types could also work with classes, and
inheritance. In this case it would be important to break the
functionality that is currently provided by {\bf extends}, so that 
code can be inherited without creating a subtype at the same time. 
A similar example with classes, but also accounting for inheritance 
would be:

\begin{lstlisting}[language=java]
class B {}   // original class

// A class added later, inherits from B and becomes a supertype of B
interface A inherits B super B {} 
\end{lstlisting}

\noindent Once the functionality of {\bf extends} is broken, it also
becomes possible to inherit code without creating any subtype
relation. This is for example the situation that is dicussed by Cook
et al.~\cite{}. We should note that Ostermann~\cite{}\bruno{others?}
also proposes a similar feature to retroactive super types.

\paragraph{Contravariant Subtyping Refinement of Arguments}
Another feature that is missing from mainstream OOP languages is 
contravariant refinement of argument types. Most Java-like OOP language support covariant return type 
refinement. That is:

\begin{lstlisting}
interface A  {A m();} 

interface B  extends A {B m();} // B extends and refines the return type of m()
\end{lstlisting}

\noindent From the theory of OOP languages, we know that an equally
valid form of refinement also applies to method arguments~\cite{}. However 
the refinement on method arguments is contravariant. For an
extended type to become a subtype under argument refinements in
methods, it is necessary that the  that the arguments of the methods
in the subtypes become supertypes. The following example illustrates 
this: 

\begin{lstlisting}
interface A  {Int m(String s);} 

interface B  extends A {Int m(Object s);} // B extends and refines the return type of m()
\end{lstlisting}

\noindent Unfortunatelly this is invalid Java code, since Java 
does not support contravariant subtyping refinement of arguments. 
A possible reason for not having such feature is that there are not
many applications where this feature \emph{in isolation} seems necessary. 

\begin{figure}
\begin{lstlisting}[language=java]
interface ExpVisitor<A> { // Base Visitor and Language
	A lit(int x);
	A add(A e1, A e2);
}

interface Exp { // Simple AST for expressions
	<A> A accept(ExpVisitor<A> v);
}

interface ExtExpVisitor<A> extends ExpVisitor<A> { // Extended Visitor and Language
	A sub(A e1, A e2);
}

interface ExtExp super Exp { // An extended AST becomes a supertype of the original one
	<A> A accept(ExtExpVisitor<A> v); // Contravariant argument refinement
}
\end{lstlisting}
\caption{Extensible Visitors in an hyphotetical
  extension of Java with Retroactive Super Types and Contravariant
  Type Refinement.}
\label{fig:JVis}
\end{figure}

\paragraph{Combining Retroactive Super Types with Contravariant Refinement}
However, combined with retroactive super types, contravariant
refinement of argument types becomes 
much more interesting! In particular we claim that this combination is 
helpful in dealing with modularity/reuse problems that arize in
visitors and Object Algebras. There have been several attempts 
at making visitors extensible in the past~\cite{}. However most
attempts usually rely on advanced type system features. With retroactive super
types and contravariant refinement, extensible visitors and improved
variants of Object Algebras could be achieved more naturally.  

Figure~\ref{fig:JVis} presents pseudo Java code that uses the two
features in combination. The interface \lstinline{ExpVisitor} represents a
visitor interface for a simple AST containing literals and
additions. \bruno{Since later we will talk about Object Algebras, we
  chose to use in} The interface \lstinline{Exp} represents the AST interface.
In a later extension, a subtraction node is added. Modelling the
extended visitor type (\lstinline{ExtExpVisitor}) is easy: just add the new visit
method (\lstinline{sub}). The interesting part is modelling the extended AST
type. The extended type (\lstinline{ExtExp}) should become a \emph{supertype} of  
\lstinline{Ext}. This follows from the fact that the new \lstinline{accept} method takes 
an argument which is a subtype of the original accept method. Thus we 
get the following subtyping relation between the signatures of the two
accept methods: \\

\lstinline{ExpVisitor<A>} $\to$ \lstinline{A} $<:$ \lstinline{ExtExpVisitor<A>} $\to$ \lstinline{A}

\noindent Here the subtype (the type on the left) is the type of the
\lstinline{accept} method in \lstinline{Exp}, and the supertype is the type of
the new \lstinline{accept} method. Since the AST type is just the
accept method, it is clear that the extended AST type should be a
supertype of the original one. 

Although such code cannot be expressed in Java, it is expressible in
\name, as shown in Section~\ref{sec:dynamic}. In fact statically typed 
OO languages using structural types should be able to express 
the example, as the subtyping relations are implict. 

\subsection{An Overly Conservative Restriction on Multiple Inheritance}

Multiple inheritance can be quite helpful to provide reuse. 
Although not all mainstream OOP languages support multiple
inheritance some of them do. For example Scala, C++ and Java 8
(with default methods) all support some form of multiple inheritance. 
However, there are some restrictions to the usage of multiple
inheritance. One of those common restrictions is that the same class (or trait)
cannot be inherited twice. We illustrate this restriction using Scala
and Scala traits (which provide a form of multiple implementation inheritance):

\begin{lstlisting}
trait A {def m(x : A) = x}

trait B extends A with A {}
\end{lstlisting}

\noindent The code is rejected with the message: ``trait A is
inherited twice''. At first sight such restriction appears
reasonable. However consider the following variant of the example 
above:

\begin{lstlisting}
trait C[A] {def m(x : A) = x}
	
trait D extends C[Int] with C[Boolean]
\end{lstlisting}

\noindent Here we create a \emph{parametrized} trait \lstinline{C}, 
defining a method \lstinline{m}. Then the trait \lstinline{D} attempts 
to inherit from \lstinline{C} twice: the first time with the type
parameter instantiated to \lstinline{Int}, and the second time with
the type 


Example: composing Object Algebras (can relate to visitors).

\jeremy{addressed in \ref{sec:dynamic} }

\subsection{No Dynamic Inheritance}

Example: find good example? Design patterns? Dynamic Proxies?

\jeremy{addressed in \ref{sec:dynamic} }

