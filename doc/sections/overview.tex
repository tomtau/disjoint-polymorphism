\section{A Critique of Mainstream Class-Based OOP}
\label{sec:critique}

This section discusses several limitations of mainstream OOP languages
that work against modularity. In particular we argue that in the
standard model of class-based OOP is grounded on the following 
assumptions:

\begin{itemize}

\item {\bf The covariant view of objects:} 

\item {\bf The view that extensions lead to subtypes:}

\item {\bf }

\end{itemize}

Those points were a driver for the
design of \name, which aims to address all of those limitations. 

\subsection{The Standard Model of Class-Based OOP}

In the standard statically typed OOP model for class-based languages
\emph{extensions} (subclasses or subinterfaces) are viewed as \emph{subtypes} of the original
class/interface. Moreover subclasses inherit from the superclasses,
and inheritance and subtyping always go along together.
This is the model adopted by most popular mainstream
languages, such as Java, C\#, C++ or Scala. This model can be traced
back to the origins of OOP in Simula~\cite{}, and has shown an 
undeniable resiliance through times. One reason why this model remains 
so popular is probably simplicity: 
extensions (of classes or interfaces) always result in subtypes.  
This results in a very simple programming model, which is easy 
to explain to programmers.  

Unfortunatelly, as the theory of OOP languages and subtyping has taught 
us that the story is not quite so simple. Since the early days of the
theoretical foundations of OOP and subtyping, it has bee

Early on Cook et al. argued
that {\bf Inheritance is not Subtyping}. \ldots

\subsection{No Retroactive Super Types and Contravariant Subtyping on Arguments}

A consequence of extensions always being subtypes is that it is not
possible to retroactivelly add super types. 

\begin{lstlisting}[language=java]
class B {}   // original class

class A super B {} // an extension, which becomes a supertype of B
\end{lstlisting}

\begin{figure}
\begin{lstlisting}[language=java]
interface ExpVisitor<A> { // Base Visitor and Language
	A lit(int x);
	A add(A e1, A e2);
}

interface Exp {
	<A> A accept(ExpVisitor<A> v);
}

interface ExtExpVisitor<A> extends ExpVisitor<A> { // Extended Visitor and Language
	A sub(A e1, A e2);
}

interface ExtExp extends Exp { //WRONG: method is overloaded, not overriden!
	<A> A accept(ExpVisitor<A> v); 
}
\end{lstlisting}
\caption{An attempt at Extensible Visitors in Java.}
\label{fig:JVis}
\end{figure}

\jeremy{addressed in \ref{sec:extensibility} }

\subsection{No Separation Between Inheritance and Subtyping}

Example: visitors.

\jeremy{addressed in \ref{sec:extensibility} }


\subsection{No Dynamic Inheritance}

Example: find good example? Design patterns? Dynamic Proxies?

\jeremy{addressed in \ref{sec:dynamic} }

\subsection{No Multiple Inheritance of Same Class}

Example: composing Object Algebras (can relate to visitors).

\jeremy{addressed in \ref{sec:dynamic} }
